http://cslibrary.stanford.edu/
http://www.idryman.org/blog/2017/07/04/learn-hash-table-the-hard-way/
https://medium.com/engineering-brainly/locality-sensitive-hashing-explained-304eb39291e4  Local sensitive hash
https://sagi.io/2017/07/bloom-filters-for-the-perplexed/
https://news.ycombinator.com/item?id=15346337
https://stackoverflow.com/questions/3260653/algorithm-to-find-top-10-search-terms/3260905#3260905

http://yucoding.blogspot.com/2017/01/leetcode-question-range-sum-query.html
http://massivealgorithms.blogspot.com/
http://ruslanledesma.com/
http://algorithms.tutorialhorizon.com/
https://www.youtube.com/watch?v=il_t1WVLNxk
https://www.youtube.com/watch?v=e5D3NepYvLE
https://www.youtube.com/watch?v=eaYX0Ee0Kcg
https://www.youtube.com/watch?v=zGv3hOORxh0
http://quiz.geeksforgeeks.org/amazons-most-frequently-asked-interview-questions-set-2/
https://www.geeksforgeeks.org/amazons-asked-interview-questions/
 
Given an array A[] of n numbers and another number x, determines whether or not there exist two elements in S whose sum is exactly x.
======================================================================================================================================

hasArrayTwoCandidates (A[], ar_size, sum)
1) Sort the array in non-decreasing order.
2) Initialize two index variables to find the candidate 
   elements in the sorted array.
       (a) Initialize first to the leftmost index: l = 0
       (b) Initialize second  the rightmost index:  r = ar_size-1
3) Loop while l < r.
       (a) If (A[l] + A[r] == sum)  then return 1
       (b) Else if( A[l] + A[r] <  sum )  then l++
       (c) Else r--    
4) No candidates in whole array - return 0
Time Complexity: Depends on what sorting algorithm we use. If we use Merge Sort or Heap Sort then (-)(nlogn) in worst case. If we use Quick Sort then O(n^2) in worst case.
Auxiliary Space : Again, depends on sorting algorithm. For example auxiliary space is O(n) for merge sort and O(1) for Heap Sort.

=========================

Pythagorean Triplet in an array
Given an array of integers, write a function that returns true if there is a triplet (a, b, c) that satisfies a2 + b2 = c2.

Method 2 (Use Sorting)
We can solve this in O(n2) time by sorting the array first.

1) Do square of every element in input array. This step takes O(n) time.

2) Sort the squared array in increasing order. This step takes O(nLogn) time.

3) To find a triplet (a, b, c) such that a = b + c, do following.

Fix ‘a’ as last element of sorted array.
Now search for pair (b, c) in subarray between first element and ‘a’. A pair (b, c) with given sum can be found in O(n) time using meet in middle algorithm discussed in method 1 of this post.
If no pair found for current ‘a’, then move ‘a’ one position back and repeat step 3.2.

class PythagoreanTriplet 
{    
    // Returns true if there is a triplet with following property
    // A[i]*A[i] = A[j]*A[j] + A[k]*[k]
    // Note that this function modifies given array
    static boolean isTriplet(int arr[], int n)
    {
        // Square array elements
        for (int i=0; i<n; i++)
            arr[i] = arr[i]*arr[i];
  
        // Sort array elements
        Arrays.sort(arr);
  
        // Now fix one element one by one and find the other two
        // elements
        for (int i = n-1; i >= 2; i--)
        {
            // To find the other two elements, start two index
            // variables from two corners of the array and move
            // them toward each other
            int l = 0; // index of the first element in arr[0..i-1]
            int r = i-1; // index of the last element in arr[0..i-1]
            while (l < r)
            {
                // A triplet found
                if (arr[l] + arr[r] == arr[i])
                    return true;
  
                // Else either move 'l' or 'r'
                if (arr[l] + arr[r] < arr[i])
                   l++;
                else
                   r--;
            }
        }
  
        // If we reach here, then no triplet found
        return false;
    }

   // Driver program to test above function
    public static void main(String[] args)
    {
        int arr[] = {3, 1, 4, 6, 5};
        int arr_size = arr.length;
        if (isTriplet(arr,arr_size)==true)
           System.out.println("Yes");
        else
           System.out.println("No");        
    }
}

===== Triplet finding in python

# Python program that returns true if there is 
# a Pythagorean Triplet in a given array.
 
# Returns true if there is Pythagorean
# triplet in ar[0..n-1]
def isTriplet(ar, n):
    # Square all the elemennts
    for i in range(n):
        ar[i] = ar[i] * ar[i]
  
    # sort array elements
    ar.sort()
  
    # fix one element
    # and find other two
    # i goes from n - 1 to 2
    for i in range(n-1, 1, -1):
        # start two index variables from 
        # two corners of the array and 
        # move them toward each other
        j = 0
        k = i - 1
        while (j < k):
            # A triplet found
            if (ar[j] + ar[k] == ar[i]):
                return True
            else:
                if (ar[j] + ar[k] < ar[i]):
                    j = j + 1
                else:
                    k = k - 1
    # If we reach here, then no triplet found
    return False
   
# Driver program to test above function */
ar = [3, 1, 4, 6, 5]
ar_size = len(ar)
if(isTriplet(ar, ar_size)):
  print("Yes")
else:
  print("No")


Prints an alphabetized list of its command-line arguments with duplicates eliminated:
--------------------------------------------------------------------------------------
 
public class WordList { 
  public static void main( String[] args) { 
   Set < String > s = new TreeSet < >(); 
   Collections.addAll( s, args); 
   System.out.println( s); 
  } 
}
ENUMS
--------------------
public enum Apple { FUJI, PIPPIN, GRANNY_SMITH }
public enum Orange { NAVEL, TEMPLE, BLOOD }




Before Java 8 - use anonymous class to sort list of strings in order of length
obsolete example:
------------------------------------------------
Collections.sort( words, new Comparator < String >() { 
     public int compare( String s1, String s2) { 
           return Integer.compare( s1. length(), s2. length());
     }
  } 
)

  In Java 8, the language formalized the notion that interfaces with a single abstract method 
are special and deserve special treatment. 

public interface Comparable < T > { int compareTo( T t); }

These interfaces are now known as functional interfaces, and the language allows you to create
instances of these interfaces using lambda expressions, or lambdas for short. 
Lambdas are similar in function to anonymous classes, but far more concise. 
Here’s how the code snippet above looks with the anonymous class replaced by a lambda. 

Lambdas are limited to functional interfaces.
-----------------------------------------------------
  
The boilerplate is gone, and the behavior is clearly evident:  
Lambda expression as function object (replaces anonymous class) 

Collections.sort( words, (s1, s2) -> Integer.compare( s1. length(), s2. length())); 
Collections.sort( words, comparingInt( String:: length));
words.sort( comparingInt( String:: length));

  
Note that the types of the lambda (Comparator < String >), of its parameters (s1 and s2, both String), 
and of its return value (int) are not present in the code. 
The compiler deduces these types from context, using a process known as type inference.


==============================
 Find Loops in a Linked-List
============================
boolean detect_loop(Node head) { 
  if (null == head) {return false; }
  Node trailing = head; 
  Node leading = head; 
  while (null != leading) {
       leading = leading.next;   //1st time  
       if (trailing == leading) {return true; }
       trailing = trailing.next; //1st time
       if (null != leading) {
          leading = leading.next; //2nd time 
       }
  }
return false; 
}

=====================================================


public interface Queue<E>
extends Collection<E>
A collection designed for holding elements prior to processing. 
Besides basic Collection operations, queues provide additional insertion, extraction, and inspection operations. 
Each of these methods exists in two forms: one throws an exception if the operation fails, the other returns a special value (either null or false, depending on the operation). The latter form of the insert operation is designed specifically for use with capacity-restricted Queue implementations; in most implementations, insert operations cannot fail.
Throws exception	 | Returns special value
----------------------------------------
Insert	add(e)	    |  offer(e)
Remove	remove()	  |  poll()
Examine	element()	|  peek()

Queues typically, but do not necessarily, order elements in a FIFO (first-in-first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator, or the elements' natural ordering, and LIFO queues (or stacks) which order the elements LIFO (last-in-first-out). 
Whatever the ordering used, the head of the queue is that element which would be removed by a call to remove() or poll(). In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties.

The offer() method inserts an element if possible, otherwise returning false. This differs from the Collection.add() method, which can fail to add an element only by throwing an unchecked exception. The offer() method is designed for use when failure is a normal, rather than exceptional occurrence, for example, in fixed-capacity (or "bounded") queues.

The remove() and poll() methods remove and return the head of the queue. Exactly which element is removed from the queue is a function of the queue's ordering policy, which differs from implementation to implementation. The remove() and poll() methods differ only in their behavior when the queue is empty: the remove() method throws an exception, while the poll() method returns null.

The element() and peek() methods return, but do not remove, the head of the queue.


public ListNode mergeKLists(ListNode[] lists) {
    if(lists==null||lists.length==0)
        return null;
 
    PriorityQueue<ListNode> queue = new PriorityQueue<ListNode>(new Comparator<ListNode>(){
        public int compare(ListNode l1, ListNode l2){
            return l1.val - l2.val;
        }
    });
 
    ListNode head = new ListNode(0);
    ListNode p = head;
 
    for(ListNode list: lists){
        if(list!=null)
            queue.offer(list);  // insert 
    }    
 
    while(!queue.isEmpty()){
        ListNode n = queue.poll();   //remove 
        p.next = n;
        p=p.next;
 
        if(n.next!=null)
            queue.offer(n.next);   //insert
    }    
 
    return head.next;
 
}



============= is array contains duplicates ==== ?

Solution 1:
public boolean containsDuplicate(int[] nums) {
    Arrays.sort(nums);
    for (int i = 0; i < nums.length - 1; ++i) {
        if (nums[i] == nums[i + 1]) return true;
    }
    return false;
}

Solution 2:
public boolean containsDuplicate(int[] nums) {
    Set<Integer> set = new HashSet<>(nums.length);
    for (int x: nums) {
        if (set.contains(x)) return true;
        set.add(x);
    }
    return false;
}



==== 2 sum problem ==========================

public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        int complement = target - nums[i];
        if (map.containsKey(complement)) {
            return new int[] { map.get(complement), i };
        }
        map.put(nums[i], i);
    }
    throw new IllegalArgumentException("No two sum solution");
}


Fast string matching
====================
https://github.com/phaistos-networks/Trinity   Inverted index in C++
https://medium.com/towards-data-science/symspell-vs-bk-tree-100x-faster-fuzzy-string-search-spell-checking-c4f10d80a078
http://blog.faroo.com/2015/03/24/fast-approximate-string-matching-with-large-edit-distances/
https://medium.com/@Pinterest_Engineering/introducing-pixie-an-advanced-graph-based-recommendation-system-e7b4229b664b
https://habrahabr.ru/company/mailru/blog/267469/   Поисковые подсказки изнутри

Task: are linked lists intersected?
===================================
Approach#1
-----------
First while loop counts the number of nodes in the first list.
Second while loop counts the number of nodes in the second list.
After having the length of each list, we find the difference in number of nodes and 
then move whichever pointer that points to the longer list ahead using that difference.
Finally, the while loop is used to find the intersection. We just loop until either of the pointers reaches the end of its list. 
During the loop, if the pointers meet, we return true immediately because it means that the lists intersect. 

But at the end of the loop and nothing has happened, we simply return false because the lists don't intersect.

Approach#2
-----------
Compare the last elements in lists:
private static boolean areListsIntersected(Node list1, Node list2){
   return Tail(list1) == Tail(list2);
}

private static Node Tail(Node list) {
     if (list == null) return list;

     while (list.next != null) {
          list = list.next;
     }

     return list;  //this is the last item in list
}

https://en.wikipedia.org/wiki/Optimal_substructure


Task: find path on board
=========================
http://www.geeksforgeeks.org/backttracking-set-2-rat-in-a-maze/
http://www.geeksforgeeks.org/shortest-path-in-a-binary-maze/
http://algorithms.tutorialhorizon.com/dynamic-programming-minimum-cost-path-problem/
http://algorithms.tutorialhorizon.com/dynamic-programming-count-all-paths-in-2d-matrix-with-obstructions-in-it/
http://algorithms.tutorialhorizon.com/dynamic-programming-count-all-paths-from-top-left-to-bottom-right-of-a-mxn-matrix/



http://joaoff.com/2008/01/20/a-square-grid-path-problem/
http://articles.leetcode.com/unique-paths/

import java.util.Arrays;

public class Backtrack {

    public static void main(String... args) {
        int[][] inputArray = {
                { 1, 1, 1, 0, 0 },
                { 0, 1, 1, 0, 0 },
                { 0, 1, 0, 1, 0 },
                { 0, 1, 1, 1, 1 } };
        int[][] findPath = findPath(inputArray);
        System.out.println(Arrays.deepToString(findPath));

    }

    public static int[][] findPath(int[][] maze) {
        int[][] solution = new int[maze.length][];
        for (int i = 0; i < maze.length; i++) {
            solution[i] = new int[maze[i].length];
        }
        if (!findPath(maze, solution, 0, 0)) {
            System.out.println("Didn't find a solution.");
        }
        return solution;
    }

    private static boolean findPath(int[][] maze, int[][] solution, int x, int y) {
        if (0 <= y && y < maze.length && 0 <= x && x < maze[y].length) {
            if (y == maze.length - 1 && x == maze[y].length - 1) {
                solution[y][x] = 1;
                return true;
            } else if (solution[y][x] != 1 && maze[y][x] == 1) {
                solution[y][x] = 1;
                if (findPath(maze, solution, x, y + 1)
                        || findPath(maze, solution, x + 1, y)
                        || findPath(maze, solution, x - 1, y)
                        || findPath(maze, solution, x, y - 1)) {
                    return true;
                }
                solution[y][x] = 0;
            }
        }
        return false;
    }
}



Change-making problem
====================
https://en.wikipedia.org/wiki/Change-making_problem
http://algorithms.tutorialhorizon.com/dynamic-programming-coin-change-problem/
http://algorithms.tutorialhorizon.com/dynamic-programming-minimum-coin-change-problem/

Finding the minimum number of coins (of certain denominations) that add up to a given amount of money. It is a knapsack type problem

Write an algorithm to find out how many ways we can make the change of the amount using the coins given.
Recursive solution (2^n)

public static int total(int n, int[] v, int i) {
        if (n < 0) {
            return 0;
        }
        if (n == 0) {
            return 1;
        }
        // means coins over and n>0 so no solution
        if (i == v.length && n > 0) {
            return 0;
        }
        return total(n - v[i], v, i) + total(n, v, i + 1);
    }





Task: Given stock price of n days,  make at most k transactions, new transaction can only start after previous transaction is complete, find out maximum profit.
===========================================================================================
http://www.geeksforgeeks.org/maximum-profit-by-buying-and-selling-a-share-at-most-k-times/
http://www.geeksforgeeks.org/maximum-profit-by-buying-and-selling-a-share-at-most-twice/
http://keithschwarz.com/interesting/
Task: largest sum of sequential numbers
=======================================
https://en.wikipedia.org/wiki/Maximum_subarray_problem
$cur = $max = 0;
foreach ($seq as $n)
{
  $cur += $n;
  if ($cur < 0) $cur = 0;
  if ($cur > $max) $max = $cur;
}

Task: The biggest profit for a given stock over a period of time in the past  (we are allowed to buy and sell multiple times)
==============================================================================================
https://www.youtube.com/watch?v=oDhu5uGq_ic

Following is algorithm for this problem.
1. Find the local minima and store it as starting index. If not exists, return.
2. Find the local maxima. and store it as ending index. If we reach the end, set the end as ending index.
3. Update the solution (Increment count of buy sell pairs)
4. Repeat the above steps if end is not reached.


import java.util.ArrayList;

// Solution structure
class Interval
{
    int buy, sell;
}

class StockBuySell
{
    // This function finds the buy sell schedule for maximum profit
    void stockBuySell(int price[], int n)
    {
        // Prices must be given for at least two days
        if (n == 1)
            return;

        int count = 0;

        // solution array
        ArrayList<Interval> sol = new ArrayList<Interval>();

        // Traverse through given price array
        int i = 0;
        while (i < n - 1)
        {
            // Find Local Minima. Note that the limit is (n-2) as we are
            // comparing present element to the next element.
            while ((i < n - 1) && (price[i + 1] <= price[i]))
                i++;

            // If we reached the end, break as no further solution possible
            if (i == n - 1)
                break;

            Interval e = new Interval();
            e.buy = i++;
            // Store the index of minima


            // Find Local Maxima.  Note that the limit is (n-1) as we are
            // comparing to previous element
            while ((i < n) && (price[i] >= price[i - 1]))
                i++;

            // Store the index of maxima
            e.sell = i-1;
            sol.add(e);

            // Increment number of buy/sell
            count++;
        }

        // print solution
        if (count == 0)
            System.out.println("There is no day when buying the stock "
                                                  + "will make profit");
        else
            for (int j = 0; j < count; j++)
                System.out.println("Buy on day: " + sol.get(j).buy
                        +"        " + "Sell on day : " + sol.get(j).sell);

        return;
    }

    public static void main(String args[])
    {
        StockBuySell stock = new StockBuySell();

        // stock prices on consecutive days
        int price[] = {100, 180, 260, 310, 40, 535, 695};
        int n = price.length;

        // fucntion call
        stock.stockBuySell(price, n);
    }
}



Task:  the biggest profit for a given stock over a period of time in the past (1 buy + 1 sell)
==============================================================================================
http://www.geeksforgeeks.org/maximum-difference-between-two-elements/
https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/
https://stackoverflow.com/questions/7086464/maximum-single-sell-profit
In formal terms, we need to find  max(prices[j] - prices[i])  for every i and j such that j > i


take the difference with the minimum element found so far. So we need to keep track of 2 things:
1) Maximum difference found so far (max_diff).
2) Minimum number visited so far (min_element).



public class Solution {
    public int maxProfit(int prices[]) {
        int minprice = Integer.MAX_VALUE;
        int maxprofit = 0;
        for (int i = 0; i < prices.length; i++) {
            if (prices[i] < minprice)
                minprice = prices[i];
            else if (prices[i] - minprice > maxprofit)
                maxprofit = prices[i] - minprice;
        }
        return maxprofit;
    }
}


class MaximumDiffrence
{
    /* The function assumes that there are at least two
       elements in array.
       The function returns a negative value if the array is
       sorted in decreasing order.
       Returns 0 if elements are equal  */
    int maxDiff(int arr[], int arr_size)
    {
        int max_diff = arr[1] - arr[0];
        int min_element = arr[0];
        int i;
        for (i = 1; i < arr_size; i++)
        {
            if (arr[i] - min_element > max_diff)
                max_diff = arr[i] - min_element;
            if (arr[i] < min_element)
                min_element = arr[i];
        }
        return max_diff;
    }

    /* Driver program to test above functions */
    public static void main(String[] args)
    {
        MaximumDiffrence maxdif = new MaximumDiffrence();
        int arr[] = {1, 2, 90, 10, 110};
        int size = arr.length;
        System.out.println("MaximumDifference is " +
                                maxdif.maxDiff(arr, size));
    }
}


 A = [1, 2, 1, 5, 2, 6, 0]. The solution for each prefix of A is the following.

Prefix sequence    : Solution for prefix / Current candidate solution for A
1                  : 0
1, 2               : 1
1, 2, 1            : 1
1, 2, 1, 5         : 4
1, 2, 1, 5, 2      : 4
1, 2, 1, 5, 2, 6   : 5
1, 2, 1, 5, 2, 6, 0: 5


F(A, len)
 1: min := A[1] IF len > 0
 2: max := 0
 3: FOR i := 2 TO len
 4:   IF A[i] - min > max
 5:     max := A[i] - min
 6:   IF A[i] < min
 7:     min := A[i]
 8: RETURN max

import java.util.Scanner;

public class main {

  private static int MAX_LEN = 1000000;

  private static int algG(int[] A) {
    int min = A.length > 0 ? A[0] : 0;
    int max = 0;
      for(int i = 0; i < A.length; i++)
        if(A[i] < min)
          min = A[i];
        else if(A[i] - min > max)
          max = A[i] - min;
    return max;
  }

  public static void main(String[] args) {
    int[] A = new int[MAX_LEN];
    int len = 0;
    int n;
    Scanner in = new Scanner(System.in);
    while(in.hasNextInt())
      A[len++] = in.nextInt();
    System.out.println(algG(A));
  }
}

Task: Implement Queue using Stacks  http://www.geeksforgeeks.org/?p=5009
========================================================================

Stack: insertion and deletion are happend on the same end: Last-In First-Out (LIFO)
Queue: First-In First-Out (FIFO)


Method 2 (By making deQueue operation costly)
In this method, in en-queue operation, the new element is entered at the top of stack1.
In de-queue operation, if stack2 is empty then all the elements are moved to stack2 and finally top of stack2 is returned.

enQueue(q,  x)
  1) Push x to stack1 (assuming size of stacks is unlimited).

deQueue(q)
  1) If both stacks are empty then error.
  2) If stack2 is empty
       While stack1 is not empty, push everything from stack1 to stack2.
  3) Pop the element from stack2 and return it.

import java.util.Stack;

public class GFG
{
    /* class of queue having two stacks */
    static class Queue
    {
        Stack<Integer> stack1 ;
        Stack<Integer> stack2 ;
    }

    /* Function to push an item to stack*/
    static void push(Stack<Integer> top_ref, int new_data)
    {
        //Push the data onto the stack
        top_ref.push(new_data);
    }

    /* Function to pop an item from stack*/
    static int pop(Stack<Integer> top_ref)
    {
        /*If stack is empty then error */
        if(top_ref.isEmpty())
        {
            System.out.println("Stack Overflow");
            System.exit(0);
        }
        //pop the data from the stack
        return top_ref.pop();
    }
    //Function to enqueue an item to the queue
    static void enQueue(Queue q, int x)
    {
        push(q.stack1, x);
    }
    /* Function to dequeue an item from queue */
    static int deQueue(Queue q)
    {
        int x;
        /* If both stacks are empty then error */
        if(q.stack1.isEmpty() && q.stack2.isEmpty() )
        {
            System.out.println("Q is empty");
            System.exit(0);
        }

        /* Move elements from stack1 to stack 2 only if
        stack2 is empty */
        if(q.stack2.isEmpty())
        {
            while(!q.stack1.isEmpty())
            {
            x = pop(q.stack1);
            push(q.stack2, x);

            }
        }
        x = pop(q.stack2);
        return x;
    }

    /* Driver function to test above functions */
    public static void main(String args[])
    {
        /* Create a queue with items 1 2 3*/
        Queue q= new Queue();
        q.stack1 = new Stack<>();
        q.stack2 = new Stack<>();
        enQueue(q, 1);
        enQueue(q, 2);
        enQueue(q, 3);

        /* Dequeue items */
        System.out.print(deQueue(q)+" ");
        System.out.print(deQueue(q)+" ");
        System.out.println(deQueue(q)+" ");
    }
}

Task: Implement a Stack data structure using 2 Queues
=========================================================
Given a Queue data structure that supports standard operations like enqueue() and dequeue().

Method 1 (By making push operation costly)
----------
This method makes sure that newly entered element is always at the front of ‘q1’,
so that pop operation just dequeues from ‘q1’.
‘q2’ is used to put every new element at front of ‘q1’.

push(s, x) // x is the element to be pushed and s is stack
  1) Enqueue x to q2
  2) One by one dequeue everything from q1 and enqueue to q2.
  3) Swap the names of q1 and q2
// Swapping of names is done to avoid one more movement of all elements from q2 to q1.

pop(s)
  1) Dequeue an item from q1 and return it.


  Method 2 (By making pop operation costly)
  ----------
In push operation, the new element is always enqueued to q1.
In pop() operation, if q2 is empty then all the elements except the last, are moved to q2.
Finally the last element is dequeued from q1 and returned.

push(s,  x)
  1) Enqueue x to q1 (assuming size of q1 is unlimited).

pop(s)
  1) One by one dequeue everything except the last element from q1 and enqueue to q2.
  2) Dequeue the last item of q1, the dequeued item is result, store it.
  3) Swap the names of q1 and q2
  4) Return the item stored in step 2.
// Swapping of names is done to avoid one more movement of all elements  from q2 to q1.



Task: Implement a stack using a single queue   http://www.geeksforgeeks.org/implement-a-stack-using-single-queue/
=============================================

 This solution assumes that we can find size of queue at any point.
 The idea is to keep newly inserted element always at front, keeping order of previous elements same. Below are complete steps.

// x is the element to be pushed and s is stack
push(s, x)
  1) Let size of q be s.
  1) Enqueue x to q
  2) One by one Dequeue s items from queue and enqueue them.

// Removes an item from stack
pop(s)
  1) Dequeue an item from q


// Java program to implement stack using a
// single queue

import java.util.LinkedList;
import java.util.Queue;

public class stack
{
    Queue<Integer> q = new LinkedList<Integer>();

    // Push operation
    void push(int val)
    {
        // get previous size of queue
        int size = q.size();

        // Add current element
        q.add(val);

        // Pop (or Dequeue) all previous
        // elements and put them after current
        // element
        for (int i = 0; i < size; i++)
        {
            // this will add front element into
            // rear of queue
            int x = q.remove();
            q.add(x);
        }
    }

    // Removes the top element
    int pop()
    {
        if (q.isEmpty())
        {
            System.out.println("No elements");
            return -1;
        }
        int x = q.remove();
        return x;
    }

    // Returns top of stack
    int top()
    {
        if (q.isEmpty())
            return -1;
        return q.peek();
    }

    // Returns true if Stack is empty else false
    boolean isEmpty()
    {
        return q.isEmpty();
    }

    // Driver program to test above methods
    public static void main(String[] args)
    {
        stack s = new stack();
        s.push(10);
        s.push(20);
        System.out.println("Top element :" + s.top());
        s.pop();
        s.push(30);
        s.pop();
        System.out.println("Top element :" + s.top());
    }
}

Pre-order: print root,  left, right
----------
Check if the current node is empty / null.
Display the data part of the root (or current node).
Traverse the left subtree by recursively calling the pre-order function.
Traverse the right subtree by recursively calling the pre-order function.

PreOrder traversal is used to create a copy of the tree. 
Preorder traversal is also used to get prefix expression on of an expression tree.
Please see http://en.wikipedia.org/wiki/Polish_notation to know why prefix expressions are useful.


In-order:   left, print root, right
-----------
Check if the current node is empty / null.
Traverse the left subtree by recursively calling the in-order function.
Display the data part of the root (or current node).
Traverse the right subtree by recursively calling the in-order function.
In a binary search tree, in-order traversal retrieves data in sorted order

Post-order: left, right, print root
-----------
Check if the current node is empty / null.
Traverse the left subtree by recursively calling the post-order function.
Traverse the right subtree by recursively calling the post-order function.
Display the data part of the root (or current node).

Postorder traversal is used to delete the tree. Please see the question for deletion of tree for details. 
Postorder traversal is also useful to get the postfix expression of an expression tree. 
Please see http://en.wikipedia.org/wiki/Reverse_Polish_notation to for the usage of postfix expression.
