


http://cslibrary.stanford.edu/
http://www.idryman.org/blog/2017/07/04/learn-hash-table-the-hard-way/
https://medium.com/engineering-brainly/locality-sensitive-hashing-explained-304eb39291e4  Local sensitive hash
https://sagi.io/2017/07/bloom-filters-for-the-perplexed/
https://news.ycombinator.com/item?id=15346337
https://stackoverflow.com/questions/3260653/algorithm-to-find-top-10-search-terms/3260905#3260905

http://yucoding.blogspot.com/2017/01/leetcode-question-range-sum-query.html
http://massivealgorithms.blogspot.com/
http://ruslanledesma.com/
http://algorithms.tutorialhorizon.com/
https://www.youtube.com/watch?v=il_t1WVLNxk
https://www.youtube.com/watch?v=e5D3NepYvLE
https://www.youtube.com/watch?v=eaYX0Ee0Kcg
https://www.youtube.com/watch?v=zGv3hOORxh0
http://quiz.geeksforgeeks.org/amazons-most-frequently-asked-interview-questions-set-2/
https://www.geeksforgeeks.org/amazons-asked-interview-questions/
 
https://www.youtube.com/watch?v=eaYX0Ee0Kcg
https://www.udemy.com/11-essential-coding-interview-questions/?couponCode=AMAZON2
import heapq
import math
points = [(-2, 4), (-5, -1), (10, 1), (-5, -2), (8, 1)]

def find_smallest(pointArray, k):
    points_with_d = {}
    for point in pointArray:
        points_with_d[point] = math.sqrt(point[0]**2 + point[1]**2)
    smallest = heapq.nlargest(k, [(-value, key) for key, value in points_with_d.items()])
    return [key for value, key in smallest]

print(find_smallest(points, 3))


You can do it in O(n), so create points with distance which takes O(n), 
then a median of medians selection to find the kth smallest distance in O(n) time. 
Finally you can loop through all the distances printing out everything smaller than or equal to the kth smallest distance, 
which also takes O(n)!! Overall - O(n).? 



https://www.geeksforgeeks.org/rotate-matrix-90-degree-without-using-extra-space-set-2/
rotate matrix 90 degree




//Java implementation of SpecialStack
// Note : here we use Stack class for Stack implementation
 
import java.util.Stack;
 
/* A class that supports all the stack operations and one additional
operation getMin() that returns the minimum element from stack at
any time. This class inherits from the stack class and uses an
auxiliarry stack that holds minimum elements */
 
class SpecialStack extends Stack<Integer>
{
    Stack<Integer> min = new Stack<>();
     
    /* SpecialStack's member method to insert an element to it. This method
    makes sure that the min stack is also updated with appropriate minimum
    values */
    void push(int x)
    {
        if(isEmpty() == true)
        {
            super.push(x);
            min.push(x);
        }
        else
        {
            super.push(x);
            int y = min.pop();
            min.push(y);
            if(x < y)
                min.push(x);
            else
                min.push(y);
        }
    }
 
    /* SpecialStack's member method to insert an element to it. This method
    makes sure that the min stack is also updated with appropriate minimum
    values */
    public Integer pop()
    {
        int x = super.pop();
        min.pop();
        return x;
    }
 
    /* SpecialStack's member method to get minimum element from it. */
    int getMin()
    {
        int x = min.pop();
        min.push(x);
        return x;
    }
 
    /* Driver program to test SpecialStack methods */
    public static void main(String[] args) 
    {
        SpecialStack s = new SpecialStack();
        s.push(10);
        s.push(20);
        s.push(30);
        System.out.println(s.getMin());
        s.push(5);
        System.out.println(s.getMin());
    }
} 
--------------------

/ Recursive Java program for level order traversal of Binary Tree
 
/* Class containing left and right child of current 
   node and key value*/
class Node
{
    int data;
    Node left, right;
    public Node(int item)
    {
        data = item;
        left = right = null;
    }
}
 
class BinaryTree
{
    // Root of the Binary Tree
    Node root;
 
    public BinaryTree()
    {
        root = null;
    }
 
    /* function to print level order traversal of tree*/
    void printLevelOrder()
    {
        int h = height(root);
        int i;
        for (i=1; i<=h; i++)
            printGivenLevel(root, i);
    }
 
    /* Compute the "height" of a tree -- the number of
    nodes along the longest path from the root node
    down to the farthest leaf node.*/
    int height(Node root)
    {
        if (root == null)
           return 0;
        else
        {
            /* compute  height of each subtree */
            int lheight = height(root.left);
            int rheight = height(root.right);
             
            /* use the larger one */
            if (lheight > rheight)
                return(lheight+1);
            else return(rheight+1); 
        }
    }
 
    /* Print nodes at the given level */
    void printGivenLevel (Node root ,int level)
    {
        if (root == null)
            return;
        if (level == 1)
            System.out.print(root.data + " ");
        else if (level > 1)
        {
            printGivenLevel(root.left, level-1);
            printGivenLevel(root.right, level-1);
        }
    }
     
    /* Driver program to test above functions */
    public static void main(String args[])
    {
       BinaryTree tree = new BinaryTree();
       tree.root= new Node(1);
       tree.root.left= new Node(2);
       tree.root.right= new Node(3);
       tree.root.left.left= new Node(4);
       tree.root.left.right= new Node(5);
        
       System.out.println("Level order traversal of binary tree is ");
       tree.printLevelOrder();
    }
}
=========diameter of tree
The diameter of a tree T is the largest of the following quantities:
* the diameter of T’s left subtree
* the diameter of T’s right subtree
* the longest path between leaves that goes through the root of T (this can be computed from the heights of the subtrees of T) 
Implementation: Java

// Recursive optimized Java program to find the diameter of a
// Binary Tree
 
/* Class containing left and right child of current
 node and key value*/
class Node
{
    int data;
    Node left, right;
 
    public Node(int item)
    {
        data = item;
        left = right = null;
    }
}
 
/* Class to print the Diameter */
class BinaryTree
{
    Node root;
 
    /* Method to calculate the diameter and return it to main */
    int diameter(Node root)
    {
        /* base case if tree is empty */
        if (root == null)
            return 0;
 
        /* get the height of left and right sub trees */
        int lheight = height(root.left);
        int rheight = height(root.right);
 
        /* get the diameter of left and right subtrees */
        int ldiameter = diameter(root.left);
        int rdiameter = diameter(root.right);
 
        /* Return max of following three
          1) Diameter of left subtree
         2) Diameter of right subtree
         3) Height of left subtree + height of right subtree + 1 */
        return Math.max(lheight + rheight + 1,
                        Math.max(ldiameter, rdiameter));
 
    }
 
    /* A wrapper over diameter(Node root) */
    int diameter()
    {
        return diameter(root);
    }
 
    /*The function Compute the "height" of a tree. Height is the
      number f nodes along the longest path from the root node
      down to the farthest leaf node.*/
    static int height(Node node)
    {
        /* base case tree is empty */
        if (node == null)
            return 0;
 
        /* If tree is not empty then height = 1 + max of left
           height and right heights */
        return (1 + Math.max(height(node.left), height(node.right)));
    }
 
    public static void main(String args[])
    {
        /* creating a binary tree and entering the nodes */
        BinaryTree tree = new BinaryTree();
        tree.root = new Node(1);
        tree.root.left = new Node(2);
        tree.root.right = new Node(3);
        tree.root.left.left = new Node(4);
        tree.root.left.right = new Node(5);
 
        System.out.println("The diameter of given binary tree is : "
                           + tree.diameter());
    }
}
------ python --------
# Python program to find the diameter of binary tree
 
# A binary tree node
class Node:
 
    # Constructor to create a new node
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None
 
 
"""
The function Compute the "height" of a tree. Height is the 
number f nodes along the longest path from the root node 
down to the farthest leaf node.
"""
def height(node):
     
    # Base Case : Tree is empty
    if node is None:
        return 0 ;
     
    # If tree is not empty then height = 1 + max of left 
    # height and right heights 
    return 1 + max(height(node.left) ,height(node.right))
 
# Function to get the diamtere of a binary tree
def diameter(root):
     
    # Base Case when tree is empty 
    if root is None:
        return 0;
 
    # Get the height of left and right sub-trees
    lheight = height(root.left)
    rheight = height(root.right)
 
    # Get the diameter of left and irgh sub-trees
    ldiameter = diameter(root.left)
    rdiameter = diameter(root.right)
 
    # Return max of the following tree:
    # 1) Diameter of left subtree
    # 2) Diameter of right subtree
    # 3) Height of left subtree + height of right subtree +1 
    return max(lheight + rheight + 1, max(ldiameter, rdiameter))
     
 
# Driver program to test above functions 
 
"""
Constructed binary tree is 
            1
          /   \
        2      3
      /  \
    4     5
"""
 
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)
print "Diameter of given binary tree is %d" %(diameter(root))
 
# This code is contributed by Nikhil Kumar Singh(nickzuck_007)
Run on IDE


Time Complexity: O(n^2)

Output:
Diameter of the given binary tree is 4


Optimized implementation: The above implementation can be optimized by calculating the height in the same recursion rather than calling a height() separately. Thanks to Amar for suggesting this optimized version. This optimization reduces time complexity to O(n).
C
Java
/*The second parameter is to store the height of tree.
   Initially, we need to pass a pointer to a location with value
   as 0. So, function should be used as follows:
 
   int height = 0;
   struct node *root = SomeFunctionToMakeTree();
   int diameter = diameterOpt(root, &height); */
int diameterOpt(struct node *root, int* height)
{
  /* lh --> Height of left subtree
     rh --> Height of right subtree */
  int lh = 0, rh = 0;
  
  /* ldiameter  --> diameter of left subtree
     rdiameter  --> Diameter of right subtree */
  int ldiameter = 0, rdiameter = 0;
  
  if(root == NULL)
  {
    *height = 0;
     return 0; /* diameter is also 0 */
  }
  
  /* Get the heights of left and right subtrees in lh and rh
    And store the returned values in ldiameter and ldiameter */
  ldiameter = diameterOpt(root->left, &lh);
  rdiameter = diameterOpt(root->right, &rh);
  
  /* Height of current node is max of heights of left and
     right subtrees plus 1*/
  *height = max(lh, rh) + 1;
  
  return max(lh + rh + 1, max(ldiameter, rdiameter));
}
==================
Find Minimum Depth of a Binary Tree
https://www.geeksforgeeks.org/find-minimum-depth-of-a-binary-tree/
Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from root node down to the nearest leaf node. 
For example, minimum height of below Binary Tree is 2.




===========
/* Java program for Dynamic Programming implementation
   of Min Cost Path problem */
import java.util.*;
 
class MinimumCostPath
{
    /* A utility function that returns minimum of 3 integers */
    private static int min(int x, int y, int z)
    {
        if (x < y)
            return (x < z)? x : z;
        else
            return (y < z)? y : z;
    }
 
    private static int minCost(int cost[][], int m, int n)
    {
        int i, j;
        int tc[][]=new int[m+1][n+1];
 
        tc[0][0] = cost[0][0];
 
        /* Initialize first column of total cost(tc) array */
        for (i = 1; i <= m; i++)
            tc[i][0] = tc[i-1][0] + cost[i][0];
 
        /* Initialize first row of tc array */
        for (j = 1; j <= n; j++)
            tc[0][j] = tc[0][j-1] + cost[0][j];
 
        /* Construct rest of the tc array */
        for (i = 1; i <= m; i++)
            for (j = 1; j <= n; j++)
                tc[i][j] = min(tc[i-1][j-1], 
                               tc[i-1][j],
                               tc[i][j-1]) + cost[i][j];
 
        return tc[m][n];
    }
 
    /* Driver program to test above functions */
    public static void main(String args[])
    {
        int cost[][]= {{1, 2, 3},
                       {4, 8, 2},
                       {1, 5, 3}};
        System.out.println("minimum cost to reach (2,2) = " +
                                         minCost(cost,2,2));
    }
}
=====  python ------
Dynamic Programming Python implementation of Min Cost Path
# problem
R = 3
C = 3
 
def minCost(cost, m, n):
 
    # Instead of following line, we can use int tc[m+1][n+1] or
    # dynamically allocate memoery to save space. The following
    # line is used to keep te program simple and make it working
    # on all compilers.
    tc = [[0 for x in range(C)] for x in range(R)]
 
    tc[0][0] = cost[0][0]
 
    # Initialize first column of total cost(tc) array
    for i in range(1, m+1):
        tc[i][0] = tc[i-1][0] + cost[i][0]
 
    # Initialize first row of tc array
    for j in range(1, n+1):
        tc[0][j] = tc[0][j-1] + cost[0][j]
 
    # Construct rest of the tc array
    for i in range(1, m+1):
        for j in range(1, n+1):
            tc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j]
 
    return tc[m][n]
 
# Driver program to test above functions
cost = [[1, 2, 3],
        [4, 8, 2],
        [1, 5, 3]]
print(minCost(cost, 2, 2))

====================================
 https://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/
 The trick is to write a utility helper function isBSTUtil(struct node* node, int min, int max) that traverses down the tree keeping track of the narrowing min and max allowed values as it goes, looking at each node only once. The initial values for min and max should be INT_MIN and INT_MAX — they narrow from there. 
/* Returns true if the given tree is a binary search tree 
 (efficient version). */ 
int isBST(struct node* node) 
{ 
  return(isBSTUtil(node, INT_MIN, INT_MAX)); 
} 

/* Returns true if the given tree is a BST and its 
 values are >= min and <= max. */ 
int isBSTUtil(struct node* node, int min, int max) 
Implementation:
C
Java
Python
//Java implementation to check if given Binary tree
//is a BST or not
 
/* Class containing left and right child of current
 node and key value*/
class Node
{
    int data;
    Node left, right;
 
    public Node(int item)
    {
        data = item;
        left = right = null;
    }
}
 
public class BinaryTree
{
    //Root of the Binary Tree
    Node root;
 
    /* can give min and max value according to your code or
    can write a function to find min and max value of tree. */
 
    /* returns true if given search tree is binary
     search tree (efficient version) */
    boolean isBST()  {
        return isBSTUtil(root, Integer.MIN_VALUE,
                               Integer.MAX_VALUE);
    }
 
    /* Returns true if the given tree is a BST and its
      values are >= min and <= max. */
    boolean isBSTUtil(Node node, int min, int max)
    {
        /* an empty tree is BST */
        if (node == null)
            return true;
 
        /* false if this node violates the min/max constraints */
        if (node.data < min || node.data > max)
            return false;
 
        /* otherwise check the subtrees recursively
        tightening the min/max constraints */
        // Allow only distinct values
        return (isBSTUtil(node.left, min, node.data-1) &&
                isBSTUtil(node.right, node.data+1, max));
    }
 
    /* Driver program to test above functions */
    public static void main(String args[])
    {
        BinaryTree tree = new BinaryTree();
        tree.root = new Node(4);
        tree.root.left = new Node(2);
        tree.root.right = new Node(5);
        tree.root.left.left = new Node(1);
        tree.root.left.right = new Node(3);
 
        if (tree.isBST())
            System.out.println("IS BST");
        else
            System.out.println("Not a BST");
    }
}

===== python 
# Python program to check if a binary tree is bst or not
 
INT_MAX = 4294967296
INT_MIN = -4294967296
 
# A binary tree node
class Node:
 
    # Constructor to create a new node
    def __init__(self, data):
        self.data = data 
        self.left = None
        self.right = None
 
 
# Returns true if the given tree is a binary search tree
# (efficient version)
def isBST(node):
    return (isBSTUtil(node, INT_MIN, INT_MAX))
 
# Retusn true if the given tree is a BST and its values
# >= min and <= max
def isBSTUtil(node, mini, maxi):
     
    # An empty tree is BST
    if node is None:
        return True
 
    # False if this node violates min/max constraint
    if node.data < mini or node.data > maxi:
        return False
 
    # Otherwise check the subtrees recursively
    # tightening the min or max constraint
    return (isBSTUtil(node.left, mini, node.data -1) and
          isBSTUtil(node.right, node.data+1, maxi))
 
# Driver program to test above function
root = Node(4)
root.left = Node(2)
root.right = Node(5)
root.left.left = Node(1)
root.left.right = Node(3)
 
if (isBST(root)):
    print "Is BST"
else:
    print "Not a BST" 
 
Given an array A[] of n numbers and another number x, determines whether or not there exist two elements in S whose sum is exactly x.
======================================================================================================================================

hasArrayTwoCandidates (A[], ar_size, sum)
1) Sort the array in non-decreasing order.
2) Initialize two index variables to find the candidate 
   elements in the sorted array.
       (a) Initialize first to the leftmost index: l = 0
       (b) Initialize second  the rightmost index:  r = ar_size-1
3) Loop while l < r.
       (a) If (A[l] + A[r] == sum)  then return 1
       (b) Else if( A[l] + A[r] <  sum )  then l++
       (c) Else r--    
4) No candidates in whole array - return 0
Time Complexity: Depends on what sorting algorithm we use. If we use Merge Sort or Heap Sort then (-)(nlogn) in worst case. If we use Quick Sort then O(n^2) in worst case.
Auxiliary Space : Again, depends on sorting algorithm. For example auxiliary space is O(n) for merge sort and O(1) for Heap Sort.

=========================

Pythagorean Triplet in an array
Given an array of integers, write a function that returns true if there is a triplet (a, b, c) that satisfies a2 + b2 = c2.

Method 2 (Use Sorting)
We can solve this in O(n2) time by sorting the array first.

1) Do square of every element in input array. This step takes O(n) time.

2) Sort the squared array in increasing order. This step takes O(nLogn) time.

3) To find a triplet (a, b, c) such that a = b + c, do following.

Fix ‘a’ as last element of sorted array.
Now search for pair (b, c) in subarray between first element and ‘a’. A pair (b, c) with given sum can be found in O(n) time using meet in middle algorithm discussed in method 1 of this post.
If no pair found for current ‘a’, then move ‘a’ one position back and repeat step 3.2.

class PythagoreanTriplet 
{    
    // Returns true if there is a triplet with following property
    // A[i]*A[i] = A[j]*A[j] + A[k]*[k]
    // Note that this function modifies given array
    static boolean isTriplet(int arr[], int n)
    {
        // Square array elements
        for (int i=0; i<n; i++)
            arr[i] = arr[i]*arr[i];
  
        // Sort array elements
        Arrays.sort(arr);
  
        // Now fix one element one by one and find the other two
        // elements
        for (int i = n-1; i >= 2; i--)
        {
            // To find the other two elements, start two index
            // variables from two corners of the array and move
            // them toward each other
            int l = 0; // index of the first element in arr[0..i-1]
            int r = i-1; // index of the last element in arr[0..i-1]
            while (l < r)
            {
                // A triplet found
                if (arr[l] + arr[r] == arr[i])
                    return true;
  
                // Else either move 'l' or 'r'
                if (arr[l] + arr[r] < arr[i])
                   l++;
                else
                   r--;
            }
        }
  
        // If we reach here, then no triplet found
        return false;
    }

   // Driver program to test above function
    public static void main(String[] args)
    {
        int arr[] = {3, 1, 4, 6, 5};
        int arr_size = arr.length;
        if (isTriplet(arr,arr_size)==true)
           System.out.println("Yes");
        else
           System.out.println("No");        
    }
}

===== Triplet finding in python

# Python program that returns true if there is 
# a Pythagorean Triplet in a given array.
 
# Returns true if there is Pythagorean
# triplet in ar[0..n-1]
def isTriplet(ar, n):
    # Square all the elemennts
    for i in range(n):
        ar[i] = ar[i] * ar[i]
  
    # sort array elements
    ar.sort()
  
    # fix one element
    # and find other two
    # i goes from n - 1 to 2
    for i in range(n-1, 1, -1):
        # start two index variables from 
        # two corners of the array and 
        # move them toward each other
        j = 0
        k = i - 1
        while (j < k):
            # A triplet found
            if (ar[j] + ar[k] == ar[i]):
                return True
            else:
                if (ar[j] + ar[k] < ar[i]):
                    j = j + 1
                else:
                    k = k - 1
    # If we reach here, then no triplet found
    return False
   
# Driver program to test above function */
ar = [3, 1, 4, 6, 5]
ar_size = len(ar)
if(isTriplet(ar, ar_size)):
  print("Yes")
else:
  print("No")


Prints an alphabetized list of its command-line arguments with duplicates eliminated:
--------------------------------------------------------------------------------------
 
public class WordList { 
  public static void main( String[] args) { 
   Set < String > s = new TreeSet < >(); 
   Collections.addAll( s, args); 
   System.out.println( s); 
  } 
}
ENUMS
--------------------
public enum Apple { FUJI, PIPPIN, GRANNY_SMITH }
public enum Orange { NAVEL, TEMPLE, BLOOD }




Before Java 8 - use anonymous class to sort list of strings in order of length
obsolete example:
------------------------------------------------
Collections.sort( words, new Comparator < String >() { 
     public int compare( String s1, String s2) { 
           return Integer.compare( s1. length(), s2. length());
     }
  } 
)

  In Java 8, the language formalized the notion that interfaces with a single abstract method 
are special and deserve special treatment. 

public interface Comparable < T > { int compareTo( T t); }

These interfaces are now known as functional interfaces, and the language allows you to create
instances of these interfaces using lambda expressions, or lambdas for short. 
Lambdas are similar in function to anonymous classes, but far more concise. 
Here’s how the code snippet above looks with the anonymous class replaced by a lambda. 

Lambdas are limited to functional interfaces.
-----------------------------------------------------
  
The boilerplate is gone, and the behavior is clearly evident:  
Lambda expression as function object (replaces anonymous class) 

Collections.sort( words, (s1, s2) -> Integer.compare( s1. length(), s2. length())); 
Collections.sort( words, comparingInt( String:: length));
words.sort( comparingInt( String:: length));

  
Note that the types of the lambda (Comparator < String >), of its parameters (s1 and s2, both String), 
and of its return value (int) are not present in the code. 
The compiler deduces these types from context, using a process known as type inference.


==============================
 Find Loops in a Linked-List
============================
boolean detect_loop(Node head) { 
  if (null == head) {return false; }
  Node trailing = head; 
  Node leading = head; 
  while (null != leading) {
       leading = leading.next;   //1st time  
       if (trailing == leading) {return true; }
       trailing = trailing.next; //1st time
       if (null != leading) {
          leading = leading.next; //2nd time 
       }
  }
return false; 
}

=====================================================


public interface Queue<E>
extends Collection<E>
A collection designed for holding elements prior to processing. 
Besides basic Collection operations, queues provide additional insertion, extraction, and inspection operations. 
Each of these methods exists in two forms: one throws an exception if the operation fails, the other returns a special value (either null or false, depending on the operation). The latter form of the insert operation is designed specifically for use with capacity-restricted Queue implementations; in most implementations, insert operations cannot fail.
Throws exception	 | Returns special value
----------------------------------------
Insert	add(e)	    |  offer(e)
Remove	remove()	  |  poll()
Examine	element()	|  peek()

Queues typically, but do not necessarily, order elements in a FIFO (first-in-first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator, or the elements' natural ordering, and LIFO queues (or stacks) which order the elements LIFO (last-in-first-out). 
Whatever the ordering used, the head of the queue is that element which would be removed by a call to remove() or poll(). In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties.

The offer() method inserts an element if possible, otherwise returning false. This differs from the Collection.add() method, which can fail to add an element only by throwing an unchecked exception. The offer() method is designed for use when failure is a normal, rather than exceptional occurrence, for example, in fixed-capacity (or "bounded") queues.

The remove() and poll() methods remove and return the head of the queue. Exactly which element is removed from the queue is a function of the queue's ordering policy, which differs from implementation to implementation. The remove() and poll() methods differ only in their behavior when the queue is empty: the remove() method throws an exception, while the poll() method returns null.

The element() and peek() methods return, but do not remove, the head of the queue.


public ListNode mergeKLists(ListNode[] lists) {
    if(lists==null||lists.length==0)
        return null;
 
    PriorityQueue<ListNode> queue = new PriorityQueue<ListNode>(new Comparator<ListNode>(){
        public int compare(ListNode l1, ListNode l2){
            return l1.val - l2.val;
        }
    });
 
    ListNode head = new ListNode(0);
    ListNode p = head;
 
    for(ListNode list: lists){
        if(list!=null)
            queue.offer(list);  // insert 
    }    
 
    while(!queue.isEmpty()){
        ListNode n = queue.poll();   //remove 
        p.next = n;
        p=p.next;
 
        if(n.next!=null)
            queue.offer(n.next);   //insert
    }    
 
    return head.next;
 
}



============= is array contains duplicates ==== ?

Solution 1:
public boolean containsDuplicate(int[] nums) {
    Arrays.sort(nums);
    for (int i = 0; i < nums.length - 1; ++i) {
        if (nums[i] == nums[i + 1]) return true;
    }
    return false;
}

Solution 2:
public boolean containsDuplicate(int[] nums) {
    Set<Integer> set = new HashSet<>(nums.length);
    for (int x: nums) {
        if (set.contains(x)) return true;
        set.add(x);
    }
    return false;
}



==== 2 sum problem ==========================

public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        int complement = target - nums[i];
        if (map.containsKey(complement)) {
            return new int[] { map.get(complement), i };
        }
        map.put(nums[i], i);
    }
    throw new IllegalArgumentException("No two sum solution");
}


Fast string matching
====================
https://github.com/phaistos-networks/Trinity   Inverted index in C++
https://medium.com/towards-data-science/symspell-vs-bk-tree-100x-faster-fuzzy-string-search-spell-checking-c4f10d80a078
http://blog.faroo.com/2015/03/24/fast-approximate-string-matching-with-large-edit-distances/
https://medium.com/@Pinterest_Engineering/introducing-pixie-an-advanced-graph-based-recommendation-system-e7b4229b664b
https://habrahabr.ru/company/mailru/blog/267469/   Поисковые подсказки изнутри

Task: are linked lists intersected?
===================================
Approach#1
-----------
First while loop counts the number of nodes in the first list.
Second while loop counts the number of nodes in the second list.
After having the length of each list, we find the difference in number of nodes and 
then move whichever pointer that points to the longer list ahead using that difference.
Finally, the while loop is used to find the intersection. We just loop until either of the pointers reaches the end of its list. 
During the loop, if the pointers meet, we return true immediately because it means that the lists intersect. 

But at the end of the loop and nothing has happened, we simply return false because the lists don't intersect.

Approach#2
-----------
Compare the last elements in lists:
private static boolean areListsIntersected(Node list1, Node list2){
   return Tail(list1) == Tail(list2);
}

private static Node Tail(Node list) {
     if (list == null) return list;

     while (list.next != null) {
          list = list.next;
     }

     return list;  //this is the last item in list
}

https://en.wikipedia.org/wiki/Optimal_substructure


Task: find path on board
=========================
http://www.geeksforgeeks.org/backttracking-set-2-rat-in-a-maze/
http://www.geeksforgeeks.org/shortest-path-in-a-binary-maze/
http://algorithms.tutorialhorizon.com/dynamic-programming-minimum-cost-path-problem/
http://algorithms.tutorialhorizon.com/dynamic-programming-count-all-paths-in-2d-matrix-with-obstructions-in-it/
http://algorithms.tutorialhorizon.com/dynamic-programming-count-all-paths-from-top-left-to-bottom-right-of-a-mxn-matrix/



http://joaoff.com/2008/01/20/a-square-grid-path-problem/
http://articles.leetcode.com/unique-paths/

import java.util.Arrays;

public class Backtrack {

    public static void main(String... args) {
        int[][] inputArray = {
                { 1, 1, 1, 0, 0 },
                { 0, 1, 1, 0, 0 },
                { 0, 1, 0, 1, 0 },
                { 0, 1, 1, 1, 1 } };
        int[][] findPath = findPath(inputArray);
        System.out.println(Arrays.deepToString(findPath));

    }

    public static int[][] findPath(int[][] maze) {
        int[][] solution = new int[maze.length][];
        for (int i = 0; i < maze.length; i++) {
            solution[i] = new int[maze[i].length];
        }
        if (!findPath(maze, solution, 0, 0)) {
            System.out.println("Didn't find a solution.");
        }
        return solution;
    }

    private static boolean findPath(int[][] maze, int[][] solution, int x, int y) {
        if (0 <= y && y < maze.length && 0 <= x && x < maze[y].length) {
            if (y == maze.length - 1 && x == maze[y].length - 1) {
                solution[y][x] = 1;
                return true;
            } else if (solution[y][x] != 1 && maze[y][x] == 1) {
                solution[y][x] = 1;
                if (findPath(maze, solution, x, y + 1)
                        || findPath(maze, solution, x + 1, y)
                        || findPath(maze, solution, x - 1, y)
                        || findPath(maze, solution, x, y - 1)) {
                    return true;
                }
                solution[y][x] = 0;
            }
        }
        return false;
    }
}



Change-making problem
====================
https://en.wikipedia.org/wiki/Change-making_problem
http://algorithms.tutorialhorizon.com/dynamic-programming-coin-change-problem/
http://algorithms.tutorialhorizon.com/dynamic-programming-minimum-coin-change-problem/

Finding the minimum number of coins (of certain denominations) that add up to a given amount of money. It is a knapsack type problem

Write an algorithm to find out how many ways we can make the change of the amount using the coins given.
Recursive solution (2^n)

public static int total(int n, int[] v, int i) {
        if (n < 0) {
            return 0;
        }
        if (n == 0) {
            return 1;
        }
        // means coins over and n>0 so no solution
        if (i == v.length && n > 0) {
            return 0;
        }
        return total(n - v[i], v, i) + total(n, v, i + 1);
    }





Task: Given stock price of n days,  make at most k transactions, new transaction can only start after previous transaction is complete, find out maximum profit.
===========================================================================================
http://www.geeksforgeeks.org/maximum-profit-by-buying-and-selling-a-share-at-most-k-times/
http://www.geeksforgeeks.org/maximum-profit-by-buying-and-selling-a-share-at-most-twice/
http://keithschwarz.com/interesting/
Task: largest sum of sequential numbers
=======================================
https://en.wikipedia.org/wiki/Maximum_subarray_problem
$cur = $max = 0;
foreach ($seq as $n)
{
  $cur += $n;
  if ($cur < 0) $cur = 0;
  if ($cur > $max) $max = $cur;
}

Task: The biggest profit for a given stock over a period of time in the past  (we are allowed to buy and sell multiple times)
==============================================================================================
https://www.youtube.com/watch?v=oDhu5uGq_ic

Following is algorithm for this problem.
1. Find the local minima and store it as starting index. If not exists, return.
2. Find the local maxima. and store it as ending index. If we reach the end, set the end as ending index.
3. Update the solution (Increment count of buy sell pairs)
4. Repeat the above steps if end is not reached.


import java.util.ArrayList;

// Solution structure
class Interval
{
    int buy, sell;
}

class StockBuySell
{
    // This function finds the buy sell schedule for maximum profit
    void stockBuySell(int price[], int n)
    {
        // Prices must be given for at least two days
        if (n == 1)
            return;

        int count = 0;

        // solution array
        ArrayList<Interval> sol = new ArrayList<Interval>();

        // Traverse through given price array
        int i = 0;
        while (i < n - 1)
        {
            // Find Local Minima. Note that the limit is (n-2) as we are
            // comparing present element to the next element.
            while ((i < n - 1) && (price[i + 1] <= price[i]))
                i++;

            // If we reached the end, break as no further solution possible
            if (i == n - 1)
                break;

            Interval e = new Interval();
            e.buy = i++;
            // Store the index of minima


            // Find Local Maxima.  Note that the limit is (n-1) as we are
            // comparing to previous element
            while ((i < n) && (price[i] >= price[i - 1]))
                i++;

            // Store the index of maxima
            e.sell = i-1;
            sol.add(e);

            // Increment number of buy/sell
            count++;
        }

        // print solution
        if (count == 0)
            System.out.println("There is no day when buying the stock "
                                                  + "will make profit");
        else
            for (int j = 0; j < count; j++)
                System.out.println("Buy on day: " + sol.get(j).buy
                        +"        " + "Sell on day : " + sol.get(j).sell);

        return;
    }

    public static void main(String args[])
    {
        StockBuySell stock = new StockBuySell();

        // stock prices on consecutive days
        int price[] = {100, 180, 260, 310, 40, 535, 695};
        int n = price.length;

        // fucntion call
        stock.stockBuySell(price, n);
    }
}



Task:  the biggest profit for a given stock over a period of time in the past (1 buy + 1 sell)
==============================================================================================
http://www.geeksforgeeks.org/maximum-difference-between-two-elements/
https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/
https://stackoverflow.com/questions/7086464/maximum-single-sell-profit
In formal terms, we need to find  max(prices[j] - prices[i])  for every i and j such that j > i


take the difference with the minimum element found so far. So we need to keep track of 2 things:
1) Maximum difference found so far (max_diff).
2) Minimum number visited so far (min_element).



public class Solution {
    public int maxProfit(int prices[]) {
        int minprice = Integer.MAX_VALUE;
        int maxprofit = 0;
        for (int i = 0; i < prices.length; i++) {
            if (prices[i] < minprice)
                minprice = prices[i];
            else if (prices[i] - minprice > maxprofit)
                maxprofit = prices[i] - minprice;
        }
        return maxprofit;
    }
}


class MaximumDiffrence
{
    /* The function assumes that there are at least two
       elements in array.
       The function returns a negative value if the array is
       sorted in decreasing order.
       Returns 0 if elements are equal  */
    int maxDiff(int arr[], int arr_size)
    {
        int max_diff = arr[1] - arr[0];
        int min_element = arr[0];
        int i;
        for (i = 1; i < arr_size; i++)
        {
            if (arr[i] - min_element > max_diff)
                max_diff = arr[i] - min_element;
            if (arr[i] < min_element)
                min_element = arr[i];
        }
        return max_diff;
    }

    /* Driver program to test above functions */
    public static void main(String[] args)
    {
        MaximumDiffrence maxdif = new MaximumDiffrence();
        int arr[] = {1, 2, 90, 10, 110};
        int size = arr.length;
        System.out.println("MaximumDifference is " +
                                maxdif.maxDiff(arr, size));
    }
}


 A = [1, 2, 1, 5, 2, 6, 0]. The solution for each prefix of A is the following.

Prefix sequence    : Solution for prefix / Current candidate solution for A
1                  : 0
1, 2               : 1
1, 2, 1            : 1
1, 2, 1, 5         : 4
1, 2, 1, 5, 2      : 4
1, 2, 1, 5, 2, 6   : 5
1, 2, 1, 5, 2, 6, 0: 5


F(A, len)
 1: min := A[1] IF len > 0
 2: max := 0
 3: FOR i := 2 TO len
 4:   IF A[i] - min > max
 5:     max := A[i] - min
 6:   IF A[i] < min
 7:     min := A[i]
 8: RETURN max

import java.util.Scanner;

public class main {

  private static int MAX_LEN = 1000000;

  private static int algG(int[] A) {
    int min = A.length > 0 ? A[0] : 0;
    int max = 0;
      for(int i = 0; i < A.length; i++)
        if(A[i] < min)
          min = A[i];
        else if(A[i] - min > max)
          max = A[i] - min;
    return max;
  }

  public static void main(String[] args) {
    int[] A = new int[MAX_LEN];
    int len = 0;
    int n;
    Scanner in = new Scanner(System.in);
    while(in.hasNextInt())
      A[len++] = in.nextInt();
    System.out.println(algG(A));
  }
}

Task: Implement Queue using Stacks  http://www.geeksforgeeks.org/?p=5009
========================================================================

Stack: insertion and deletion are happend on the same end: Last-In First-Out (LIFO)
Queue: First-In First-Out (FIFO)


Method 2 (By making deQueue operation costly)
In this method, in en-queue operation, the new element is entered at the top of stack1.
In de-queue operation, if stack2 is empty then all the elements are moved to stack2 and finally top of stack2 is returned.

enQueue(q,  x)
  1) Push x to stack1 (assuming size of stacks is unlimited).

deQueue(q)
  1) If both stacks are empty then error.
  2) If stack2 is empty
       While stack1 is not empty, push everything from stack1 to stack2.
  3) Pop the element from stack2 and return it.

import java.util.Stack;

public class GFG
{
    /* class of queue having two stacks */
    static class Queue
    {
        Stack<Integer> stack1 ;
        Stack<Integer> stack2 ;
    }

    /* Function to push an item to stack*/
    static void push(Stack<Integer> top_ref, int new_data)
    {
        //Push the data onto the stack
        top_ref.push(new_data);
    }

    /* Function to pop an item from stack*/
    static int pop(Stack<Integer> top_ref)
    {
        /*If stack is empty then error */
        if(top_ref.isEmpty())
        {
            System.out.println("Stack Overflow");
            System.exit(0);
        }
        //pop the data from the stack
        return top_ref.pop();
    }
    //Function to enqueue an item to the queue
    static void enQueue(Queue q, int x)
    {
        push(q.stack1, x);
    }
    /* Function to dequeue an item from queue */
    static int deQueue(Queue q)
    {
        int x;
        /* If both stacks are empty then error */
        if(q.stack1.isEmpty() && q.stack2.isEmpty() )
        {
            System.out.println("Q is empty");
            System.exit(0);
        }

        /* Move elements from stack1 to stack 2 only if
        stack2 is empty */
        if(q.stack2.isEmpty())
        {
            while(!q.stack1.isEmpty())
            {
            x = pop(q.stack1);
            push(q.stack2, x);

            }
        }
        x = pop(q.stack2);
        return x;
    }

    /* Driver function to test above functions */
    public static void main(String args[])
    {
        /* Create a queue with items 1 2 3*/
        Queue q= new Queue();
        q.stack1 = new Stack<>();
        q.stack2 = new Stack<>();
        enQueue(q, 1);
        enQueue(q, 2);
        enQueue(q, 3);

        /* Dequeue items */
        System.out.print(deQueue(q)+" ");
        System.out.print(deQueue(q)+" ");
        System.out.println(deQueue(q)+" ");
    }
}

Task: Implement a Stack data structure using 2 Queues
=========================================================
Given a Queue data structure that supports standard operations like enqueue() and dequeue().

Method 1 (By making push operation costly)
----------
This method makes sure that newly entered element is always at the front of ‘q1’,
so that pop operation just dequeues from ‘q1’.
‘q2’ is used to put every new element at front of ‘q1’.

push(s, x) // x is the element to be pushed and s is stack
  1) Enqueue x to q2
  2) One by one dequeue everything from q1 and enqueue to q2.
  3) Swap the names of q1 and q2
// Swapping of names is done to avoid one more movement of all elements from q2 to q1.

pop(s)
  1) Dequeue an item from q1 and return it.


  Method 2 (By making pop operation costly)
  ----------
In push operation, the new element is always enqueued to q1.
In pop() operation, if q2 is empty then all the elements except the last, are moved to q2.
Finally the last element is dequeued from q1 and returned.

push(s,  x)
  1) Enqueue x to q1 (assuming size of q1 is unlimited).

pop(s)
  1) One by one dequeue everything except the last element from q1 and enqueue to q2.
  2) Dequeue the last item of q1, the dequeued item is result, store it.
  3) Swap the names of q1 and q2
  4) Return the item stored in step 2.
// Swapping of names is done to avoid one more movement of all elements  from q2 to q1.



Task: Implement a stack using a single queue   http://www.geeksforgeeks.org/implement-a-stack-using-single-queue/
=============================================

 This solution assumes that we can find size of queue at any point.
 The idea is to keep newly inserted element always at front, keeping order of previous elements same. Below are complete steps.

// x is the element to be pushed and s is stack
push(s, x)
  1) Let size of q be s.
  1) Enqueue x to q
  2) One by one Dequeue s items from queue and enqueue them.

// Removes an item from stack
pop(s)
  1) Dequeue an item from q


// Java program to implement stack using a
// single queue

import java.util.LinkedList;
import java.util.Queue;

public class stack
{
    Queue<Integer> q = new LinkedList<Integer>();

    // Push operation
    void push(int val)
    {
        // get previous size of queue
        int size = q.size();

        // Add current element
        q.add(val);

        // Pop (or Dequeue) all previous
        // elements and put them after current
        // element
        for (int i = 0; i < size; i++)
        {
            // this will add front element into
            // rear of queue
            int x = q.remove();
            q.add(x);
        }
    }

    // Removes the top element
    int pop()
    {
        if (q.isEmpty())
        {
            System.out.println("No elements");
            return -1;
        }
        int x = q.remove();
        return x;
    }

    // Returns top of stack
    int top()
    {
        if (q.isEmpty())
            return -1;
        return q.peek();
    }

    // Returns true if Stack is empty else false
    boolean isEmpty()
    {
        return q.isEmpty();
    }

    // Driver program to test above methods
    public static void main(String[] args)
    {
        stack s = new stack();
        s.push(10);
        s.push(20);
        System.out.println("Top element :" + s.top());
        s.pop();
        s.push(30);
        s.pop();
        System.out.println("Top element :" + s.top());
    }
}

Pre-order: print root,  left, right
----------
Check if the current node is empty / null.
Display the data part of the root (or current node).
Traverse the left subtree by recursively calling the pre-order function.
Traverse the right subtree by recursively calling the pre-order function.

PreOrder traversal is used to create a copy of the tree. 
Preorder traversal is also used to get prefix expression on of an expression tree.
Please see http://en.wikipedia.org/wiki/Polish_notation to know why prefix expressions are useful.


In-order:   left, print root, right
-----------
Check if the current node is empty / null.
Traverse the left subtree by recursively calling the in-order function.
Display the data part of the root (or current node).
Traverse the right subtree by recursively calling the in-order function.
In a binary search tree, in-order traversal retrieves data in sorted order

Post-order: left, right, print root
-----------
Check if the current node is empty / null.
Traverse the left subtree by recursively calling the post-order function.
Traverse the right subtree by recursively calling the post-order function.
Display the data part of the root (or current node).

Postorder traversal is used to delete the tree. Please see the question for deletion of tree for details. 
Postorder traversal is also useful to get the postfix expression of an expression tree. 
Please see http://en.wikipedia.org/wiki/Reverse_Polish_notation to for the usage of postfix expression.
