<head>
<link rel="stylesheet" href="style.css">
</head>

<h2>Java</h2>
<pre>
<a href=https://github.com/mlubinsky/mlubinsky.github.com/tree/master/java>My Java code snippets</a>
<a href=http://tutorials.jenkov.com/java-concurrency/java-memory-model.html>Java memory model</a>

<h2>Books</h2>
<a href=https://www.amazon.com/Modern-Java-Recipes-Solutions-Difficult/dp/149197317X/>Modern Java Recepies</a>
<a href=https://www.amazon.com/Effective-Java-3rd-Joshua-Bloch/dp/0134685997>Effective Java</a>
<a href=https://www.itu.dk/~sestoft/javaprecisely/>Java Precisely</a>

<h2>Concurrency</h2>
A JVM runs in a single process and threads in a JVM share the heap belonging to that process. 
That is why several threads may access the same object. Threads share the heap and have their own stack space. 
This is how one threadâ€™s invocation of a method and its local variables are kept thread safe from other threads. 
But the heap is not thread-safe and must be synchronized for thread safety.
There are following ways to create threads in Java
1) Extending the java.lang.Thread class.
2) Implementing the java.lang.Runnable interface.
3) Implementing the java.util.concurrent.Callable interface with the java.util.concurrent.Executor framework to pool the threads. 
  The java.util.concurrent package was added in Java 5. 
4) Using the Fork/Join Pool 

<a href=http://www.vogella.com/tutorials/JavaConcurrency/article.html>Concurrency (Vogella)</a>
<a href=http://tutorials.jenkov.com/java-concurrency/index.html>Concurrency (Jenkov)</a>
<a href=https://www.pixelstech.net/article/1521976430-Java-Concurrency-Basics:-CountDownLatch-and-CyclicBarrier>CountDownLatch-and-CyclicBarrier</a>

<h2>Links</h2>
<a href=https://www.pluralsight.com/guides/java-and-j2ee/programming-with-assertions-in-java>Assertion</a>
https://www.rainerhahnekamp.com/en/ignoring-exceptions-in-java/
<a href=https://www.reddit.com/r/java/comments/8aield/executeable_java_jar_file/>Executable Jar</a>
<a href=https://coderwall.com/p/ssuaxa/how-to-make-a-jar-file-linux-executable>Executable jar</a>
<a href=https://github.com/in28minutes/java-cheat-sheet>Cheat sheet</a>

https://github.com/gaul/java-collection-overhead

x^x=0
x^y^x=y

<h2>Collection / Collections</h2>
<a href=https://github.com/in28minutes/JavaInterviewQuestionsAndAnswers>interview</a>
<a href=https://www.youtube.com/watch?v=3hgYHXDVh-o>youtube</a>

interface Collection<E> extends Iterable<E>
{
   boolean add(E e);
   boolean remove (Object o);
   int size();
   boolean isEmpty()
   void clear()
   boolean contains(Object o)
   boolean containsAll( Collection><?> c>
   boolean addAll( Collection><?> c>
   boolean removeAll( Collection><?> c>
   boolean retainAll( Collection><?> c>
   Iterator<E> iterator()
}
List Set Queue interfaces extends Collection

<h2>List</h2>
  E set ( int index, E e)
  void add(int i, E e)
  get
  set vs add
  remove
  int indexOf(Object o)
  int lastIndexOf(Object o)
  ListIterator
  List<E> sublist(int i int j)


ArraList implements List, RandomAccess
Vector is as ArrayList but syncronised
LinkList implements List, Queue (double linked list, good for implementing stack and queue)
   
<h2>Set </h2>
interface SortedSet<E> extends Set<E> {
  SortedSet<E> subSet(E from, E to)
  SortedSet<E> headSet(E from, E to)
  TailSet<E> headSet(E from, E to)
  E first()
  E last()
}

interface NavigatableSet<E> extends SortedSet
Implementation of Set interface:
class HashSet
class LinkedHashSet maintains the order of insertion
class TreeSet implements Set, NavigableSet - keeps the sorted order

Map, SortedMap, NavigableMap
get put Set<K> keySet
Map interface implementation
HashMap  - allows null keys
Hashtable - threadsafe, not allows null key
LinkedHashMap - maintains the order of insertion
TreeMap - sorted

<h2>Queue</h2>
interface Queue<E> extends Collection<E>{
  boolean add(E e) - throws exception if failure
  boolean offer(E e)  - return false if failue
  E remove() - removes head, execption
  E poll() - removes head, null if empt y
  E peek() - read but not remove
}
interface Deque<E> extends Queue<E>{
  addFirst, addLast, offerfirst,offerLast, removeFirst,removeLast
}

interface BlockingQueue<E> extends Queue<E>{

 boolean offer(E e, long timeout)
 E poll(long timeout)
 E take() - waits untile element become available
}
Implementations of Queue interface:
class
PriorityQueue,
ArrayDeque,
ArrayBlockingQueue
LinkedListBlockingQueue


<b>Collection</b> is an interface that is the parent of most of the collection interfaces defined in the collection framework.
This interface implements Iterable.
The Set and List interfaces extends Collection interface.
<b>Collections</b>, on the other hand, is a class with an exclusive collection of static methods and fields.
Examples: sort(), binarySearch(), shuffle()

<h2>Interfaces</h2>
Interfaces can have default methods.
@FunctionalInterface
Functional interfaces: only one abstract method
Examples:
public interface Predicate<T> {
   boolean test (T t);
}
public interface Comparator<T>{ //java.util.Comparator
 int compare(T o1, T o2);
}
public  interface Runnable {  //java.lang.Runnable
  void run();
}
public  interface Consumer<T> {  //java.util.function.Consumer<T>
  void accept(T t);
}
public interface Callable<V>{   //java.util.concurrent.Callable
    V call();
}

public interface Function<T,R>{
  R apply(T t);
}

Example of creating the method map() to transform list into list
using Function interface:
public static <T,R> List<R> map(List<T> list, Function<T,R> f){
  List<R> result = new ArrayList<>();
  for (T s: list){
       result.add(f.apply(s));
  }
  return result;
}
Usage:
List<Integer> lst= map{Arrays.asList("a","bb","ccc"), (String s) -> s.length()};

Another example:
import java.util.function.Function;

public class TestFrame {
   public static void main(String[] args) {
      Function<Double, Double> toDegree = (radian) -> {
         return (radian*180)/Math.PI;
      };
      System.out.println(toDegree.apply(1.5707963267948966));
   }
}

To avoid boxin/unboxing for primitive types Java8 provides specialization interfaces, for example:
public interface IntPredicate {
   boolean test (int t);
}
<h2>Comparators</h2>
Comparator<Apple> c = Comparator.comparing((Apple a) -> a.getWeight());
mylist.sort(comparing(Apple::getWeight));
mylist.sort(comparing(Apple::getWeight).reversed());
mylist.sort(comparing(Apple::getWeight).
     reversed().
     thenComparing(Apple:getCountry));
<h2>Composing predicates</h2>
Predicate<Apple> notRed = redApple.negate();
Predicate<Apple> RedAndHeavy = redApple.and(a.getWeight() > 150);
Predicate<Apple> RedAndHeavyOrGreen = redApple.and(a.getWeight() > 150).or(a->"green".equals(a.getColor()));

<h2>Composing functions</h2>
Function <Integer,Integer> f = x->x+1
Function <Integer,Integer> g = x->x+2
Function <Integer,Integer> h = f.andThen(g)
int result = h.apply(1)

Function <Integer,Integer> s = f.compose(g)
<h2>Streams</h2>
 A stream is based on internal iteration; a collection is based on external iteration.
 Streams can be directly obtained from the Arrays class as follows:

DoubleStream ds = Arrays.stream(new   double[] {10.234, 25.26, 3792.8755});
Stream<String> st = Arrays.stream(new String[] {"Spade", "Heart", "Diamond", "Club"});

<b>Intermediate operations: </b>
 filter (Predicate<T>)
 findAny findFirst   - returns Optional
 map (Function<T,R>)
 flatMap
 allMatch anyMatch noneMatch
 limit
 reduce
 sorted(Comparator<T>)
 distinct

<b>Terminal operations:</b>
 count
 collect(toList())
 forEach

 Primitive stream specialization: IntStream, DoubleStream, LongStream

  int[] numbers ={2,3,5,7}
  int sum = Arrays.stream(numbers).sum();

<h2> Labmda expressions</h2>
Old stile:
for(Car c : cars) {
  if(c.productionYear > 2007)
System.out.println(c.name);
}
New style using lambda:
cars.stream().filter((c) -> (c.productionYear > 2007))
  .forEach((c) -> {System.out.println(c.name);});

Java 8 allows add methods to interfaces and provide a default implementation
and forEach method is:
@FunctionalInterface
public interface
Iterable<T> {
    Iterator<T> iterator();
    default void forEach(Consumer<?super T> action) {
       Objects.requireNonNull(action);
       for (T t : this) {
              action.accept(t);
       }
    }
}

<h2>Optional<T> </h2>
This is container class to represent existance or absense of value
The get method returns the value if present; otherwise, NoSuchElementException is thrown.

isPresent()
ifPresent(Consumer<T> block)
T get()
T orElse(T other)

https://arnhem.luminis.eu/pure-bliss-with-pure-functions-in-java/

<h2>Processes </h2>
These processes execute in an isolated, independent manner to which resources are allocated such as:
 memory, file handles, and security credentials.
 On occasion, one process communicates with another through a communication mechanism such as:
  sockets, signals, shared memory, semaphores, and files.
<h2>Threads </h2>
<a href=https://www.youtube.com/watch?v=AfVbJDr-8ic>youtube</a>

Some classes that are designed keeping thread safety in mind are String, Hashtable, ConcurrentHashMap,
Atomic operations are thread-safe; for example, a+1 is atomic but a++ is not, because a++ means a=a+1 and consists of two operations, + (addition) and = (assignment). But, there is a way to make the increment operation atomic with the help of AtomicInteger,  AtomicBoolean, AtomicLong, AtomicLongArray.
AtomicInteger aInt=new AtomicInteger(5);
aInt.incrementAndGet();.
Local variables are thread safe because each segment has its own copy.
Volatile keywords can be used to ensure that threads do not cache variables.
Implement Runnable interface (void run()) or extend Thread class
deadlock
starvation
livelock
Priority: 1-10; default 5  Thread.setPriority(1)
Thread states:
   NEW  - obj is created, but  start() is not called yet
   RUNNABLE  eligible to run, not running yet; scheduler moves from runnable to running state
   RUNNING
   BLOCKED/WAITING
   TERMINATED/DEAD

syncronized method can be executed only by 1 thread
synchronized(this) {code here}
t1.start()
t2.start()
t3.join(time) - wait then t3 is completed
yield() method change state from running to runnable
sleep()
suspend()
wait() releases the lock; tells the calling thread to relinquish the monitor and go to sleep until some other thread calls, such as notify() or notifyAll().
notify() wakes up the thread which called wait(). And, in a similar manner, notifyAll() wakes up all the threads.
notifyAll()
ThreadGroup.activeCount()
ThreadLocal class
daemon thread -low priority; garbage collector

<h2>ForkJoinPools</h2>
https://www.java-success.com/10-%E2%99%A6-executorservice-vs-forkjoin-future-vs-completablefuture-interview-qa/

<h2>CompletableFuture</h2>
<a href=https://habrahabr.ru/post/213319/>Ru</a>
<a href=https://www.callicoder.com/java-8-completablefuture-tutorial/>Eng</a>

<h2>ExecutorService </h2>
 ExecutorService s =Executors.newSingleThreadExecutor();
 ExecutorService s =Executors.newFixedThreadsPool(10);
 ExecutorService s =Executors.newSheduledThreadPool(10);
 s.execute( new Runnable ()
      public void run(){}
 )
 s.shoutdown()

 Future f = s.submit(
    new Runnable(){  public void run(...)}
 )
  f.get()    // returns null if complete
 Callable returns result
 Future f = s.submit(
    new Callable(){
        public String call() throws exception {
           return "some_result";)
        }
 })

 f.get()    // returns result if complete


------
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
 
class Counter implements Callable<String> {
 
    private static final int THREAD_POOL_SIZE = 2;
    private AtomicInteger count = new AtomicInteger();
 
    // method where the thread execution takes place
    public String call() {
        return Thread.currentThread().getName() + " executing ..." + count.incrementAndGet(); //Consumer
    }
 
    public static void main(String[] args) throws InterruptedException,
            ExecutionException {
        // create a pool of 2 threads
        ExecutorService executor = Executors
                .newFixedThreadPool(THREAD_POOL_SIZE);
 
        Counter counter = new Counter();
        
        Future<String> future1 = executor.submit(counter);    //Producer
        Future<String> future2 = executor.submit(counter);    //Producer
 
        System.out.println(Thread.currentThread().getName() + " executing ...");
 
        //asynchronously get from the worker threads
        System.out.println(future1.get());
        System.out.println(future2.get());
 
    }
}



Java 8 has the DoubleAccumulator and the DoubleAdder new classes that allow us to have multiple threads updating the same variable,
but in fact, they update their own copy of that variable.
The trick happens when you have to read the variable.
When you have to do a read, the system will pause all threads, figure out what the value is,
update a single instance that the read is associated with and the give the correct value.


<h2>Handling Exceptions</h2>
Use checked exceptions for all exceptional events that you can anticipate and that a well-written application should be able to handle.
A checked exception extends the Exception class. A method that throws a checked exception or that calls a method that specifies a checked exception needs to either specify or handle it.

Unchecked exceptions extend the RuntimeException. Use them for internal errors that you canâ€™t anticipate and that, most often, the application canâ€™t recover from.
Methods can but donâ€™t need to handle or specify an unchecked exception. Typical examples that throw unchecked exceptions are:

- the missing initialization of a variable which results in a NullPointerException or
- the improper use of an API that causes an IllegalArgumentException

<b>AutoCloseable interface</b>
 Instantiate the object within the try clause

File file = new File("./tmp.txt");
try (FileInputStream inputStream = new FileInputStream(file);) {
  // use the inputStream to read a file
} catch (FileNotFoundException e) {
  e.printStackTrace();
} catch (IOException e) {
  e.printStackTrace();
}


Whothout Closeable  the code looks like this:

public void closeResourceInFinally() {
  FileInputStream inputStream = null;
  try {
    File file = new File("./tmp.txt");
    inputStream = new FileInputStream(file);

    // use the inputStream to read a file

  } catch (FileNotFoundException e) {
    log.error(e);
  } finally {
    if (inputStream != null) {
      try {
        inputStream.close();
      } catch (IOException e) {
        log.error(e);
      }
    }
  }
}

</pre>
