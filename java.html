<head>
<link rel="stylesheet" href="style.css">
</head>

<h2>Java</h2>
<pre>
<a href=https://github.com/mlubinsky/mlubinsky.github.com/tree/master/java>My Java code snippets</a>
<h2>Interfaces</h2>
Interfaces can have default methods.
@FunctionalInterface
Functional interfaces: only one abstract method
Examples:
public interface Predicate<T> {
   boolean test (T t);
}
public interface Comparator<T>{ //java.util.Comparator
 int compare(T o1, T o2);
}
public  interface Runnable {  //java.lang.Runnable
  void run();
}
public  interface Consumer<T> {  //java.util.function.Consumer<T>
  void accept(T t);
}
public interface Callable<V>{   //java.util.concurrent.Callable
    V call();
}

public interface Function<T,R>{
  R apply(T t);
}

Example of creating the method map() to transform list into list
using Function interface:
public static <T,R> List<R> map(List<T> list, Function<T,R> f){
  List<R> result = new ArrayList<>();
  for (T s: list){
       result.add(f.apply(s));
  }
  return result;
}
Usage:
List<Integer> lst= map{
           Arrays.asList("a","bb","ccc"), (String s) -> s.length()
};

To avoid boxin/unboxing for primitive types Java8 provides specialization interfaces, for example:

public interface IntPredicate {
   boolean test (int t);
}
<h2>Comparators</h2>
Comparator<Apple> c = Comparator.comparing((Apple a) -> a.getWeight());
mylist.sort(comparing(Apple::getWeight));
mylist.sort(comparing(Apple::getWeight).reversed());
mylist.sort(comparing(Apple::getWeight).
     reversed().
     thenComparing(Apple:getCountry));
<h2>Composing predicates</h2>
Predicate<Apple> notRed = redApple.negate();
Predicate<Apple> RedAndHeavy = redApple.and(a.getWeight() > 150);
Predicate<Apple> RedAndHeavyOrGreen = redApple.and(a.getWeight() > 150).or(a->"green".equals(a.getColor()));

<h2>Composing functions</h2>
Function <Integer,Integer> f = x->x+1
Function <Integer,Integer> g = x->x+2
Function <Integer,Integer> h = f.andThen(g)
int result = h.apply(1)

Function <Integer,Integer> s = f.compose(g)
<h2>Streams</h2>
Intermediate operations:
 filter (Predicate<T>)
 findAny findFirst   - returns Optional
 map (Function<T,R>)
 flatMap
 allMatch anyMatch noneMatch
 limit
 reduce
 sorted(Comparator<T>)
 distinct
Terminal operations:
 count
 collect(toList())
 forEach
<h2>Optional<T> </h2>
This is container class to represent existance or absense of value
isPresent()
ifPresent(Consumer<T> block)
T get()
T orElse(T other)

Primitive stream specialization: IntStream DoubleStream LongStream
int[] numbers ={2,3,5,7}
int sum = Arrays.stream(numbers).sum();
</pre>
