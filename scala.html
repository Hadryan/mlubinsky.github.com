<head>
<link rel="stylesheet" href="style.css">
</head>

<body>
<pre>
<h2>Links</h2>
<a href=https://github.com/mlubinsky/mlubinsky.github.com/tree/master/scala>My Scala code snippets</a>

https://hub.mybinder.org/user/sbrunk-almond-examples-ysx34sfv/lab .   Jupiter Notebook
https://www.youtube.com/watch?v=9AULOshbw9A
http://rcardin.github.io/design/2014/08/28/eat-that-cake.html

<a href=https://scalafiddle.io/>Scala Fiddle</a>
 
 http://appliedscala.com/ . book
 https://leanpub.com/fpmortals/read .  book Functional Programming for Mortals - ScalaZ
 
<a href=https://github.com/ikhoon/functional-programming-jargon.scala/>Functional Scala</a>
<a href=http://deeplearning.thoughtworks.school/doc/>Deep learning in Scala</a>
https://docs.google.com/presentation/d/11SfsSABS9wc6p1hIGyg70BgbALKejY2SRZIieipaTbE/edit#slide=id.g28eabcf0a1_0_564
https://functional.works-hub.com/blog/Functional-Programming-Jargon

https://hackernoon.com/practical-functional-programming-6d7932abc58b

http://www.lihaoyi.com/post/EasyParsingwithParserCombinators.html

<h2>Reactive Programming Akka</h2>
https://habr.com/company/arcadia/blog/432004/


<h2>Scala: call by value, call by name and lazy calculation</h2>
   def f (arg: Int) = println (arg)     // call by value - arg is evaluated at the point of function call
   def f (arg: => Int) = println (arg)  // call by name  - arg is evaluated at the moment of use (lazy, but it is calculated every time)

   Scala keyword <b>lazy</b>: calculated once at the moment of 1st use

<h2>High Order Function</h2>
// Apply function  n times to a value x
// nTimes (f, n, x)  = f(f(...f(x)) = nTimes(f, n-1, f(x))

def nTimes(f: Int => Int, n: Int, x: Int): Int =
   if (n < 1) x
   else nTimes(f, n-1, f(x))
             
Usage:             
 val plusOne =(x: Int) => x+1
 println(nTimes(plusOne, 10, 1)   

 Let do it differently by returning lambda:
def nTimesBetter(f: Int => Int, n: Int): (Int => Int) =
   if (n < 1) (x:Int) => x
   else (x: Int) => nTimesBetter(f, n-1) (f(x))
             
Usage:             
 val plus10 = nTimesBetter(plusOne, 10)
 println( plus10(1))     

<h2>Carried Function</h2>
val superAdder: Int => (Int=>Int) = (x: Int) => (y: Int) = x+y
val add3 = superAdder(3) // y => 3+y
println(add3(10))
println(superAdder(3)(10)) 

    Functions with muliple parameter lists:
  def curriedFormatter(c: String) (x: Double): String=c.format(x)
  val standardFormat: (Double=> String) = curriedFormatter("%4.2f")
  val precisionFormat: (Double=> String) = curriedFormatter("%10.8f")
    
  println(standardFormat(Math.PI))
  println(precisionFormat(Math.PI))
    
    
<h2>apply()</h2>
A simple use of apply is to define it on an Object. This lets you call the Object as if the object itself was a function. 
Hereâ€™s an example:

object Greet {
 def apply(name: String): String = {
   "Hello %s".format(name)
 }
}
// I can call apply explicitly if I want:
Greet.apply("bob")
Case classes provide you with an automatically generated apply function on their companion object that you can use like a constructor.
This is very confusing as it looks just like a constructor and quacks like a constructor, but it is not a constructor.


<h2>Tuples</h2>
up to Tuple22
((0,1,2,3,4),( (5,6,(7,8),9))
Tuple2[Tuple5[Int,Int,Int,Int,Int], Tuple4[Int,Int,Tuple2[Int,Int],Int]]

<h2>Reduction operations</h2>
<b>foldLeft vs fold</b>

def foldLeft[B] (z: B) (f: (B,A) => B): B
The applies a binary operator to a start value and all elements of this collection or iterator,
going left to right

The foldLeft is not parallelizable. Explanation is below:

val l=List(1,2,3,4)
val res= l.foldLeft("")(str: String, i: Int) => str+i)
Result: "1234"

val l1=List(1,2)
val l1=List(3,4)
l1.foldLeft(...) // "12"
l2.foldLeft(...) // "34"

Issue: not possible to combine results of 2 foldLeft() outputs above using the same foldLeft()
because the signature of foldLeft() 2nd arg  is a func(String,Int), not (String,String).
The foldLeft is not parallelizable and Spark does not support foldLeft() and foldRight().

def fold(z: A) f: (A,A) => A): A   // this is parallelizable because the input and output types are the same

<b>Aggregate</b>
aggregate[B] (z: => B) (seqop: (B,A) =>B, combop (B,B) => B): B  //parallelizable and can change the return type - supported by Spark!


<b>Reduce and fold</b>
val a = Array(12, 6, 15, 2, 20, 9)
val sum = a.reduceLeft(_ + _)   // same as a.reduceLeft((x,y) => x + y)
a.reduceLeft(_ * _)  // a.reduceLeft(_ min _)   //  a.reduceLeft(_ max _)

The foldLeft method works just like reduceLeft, but it lets you set a seed value to be used for the first element.

<h2>map and flatMap</h2>
    
val numbers=List(1,2,3,4)
val chars=List('a','b','c','d')
val colors=List("black","white")

val combinations=numbers.flatMap(n => chars.flatMap(c => colors.map(color => "" + c + n + "-" + color)))
println (combinations)
List(a1-black, a1-white, b1-black, b1-white, c1-black, c1-white, d1-black, d1-white, a2-black, a2-white, b2-black, b2-white, c2-black, c2-white, d2-black, d2-white, a3-black, a3-white, b3-black, b3-white, c3-black, c3-white, d3-black, d3-white, a4-black, a4-white, b4-black, b4-white, c4-black, c4-white, d4-black, d4-white)    
The same result is produced by :
val forCombinations = for {
  n <- numbers
  c <- chars
  color <- colors
} yield "" +c + n + "-"+color

println (forCombinations)
   
</pre>
