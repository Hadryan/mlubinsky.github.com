
https://habrahabr.ru/post/302936/  Graph

// Правильно, передача по ссылке
void func2(const Foo &foo) {
}


std::string s1, s2, s3;

std::string s;

s.reserve( s1.size() + s2.size() + s3.size() );
s += s1;
s += s2;
s += s3;

=========== MATRIX ==================
void print( const vector< vector<float> >& m ) {
   for( auto &row : m ) {
      for( auto x : row )
         cout << x << ' ';
      cout << endl;
   }
}

void trans( vector< vector<float> >& m ) {
   for( unsigned i = 0; i < m.size(); i++ )
      for( unsigned j = i + 1; j < m[ i ].size(); j++ ) {
         float tmp = m[ i ][ j ];
         m[ i ][ j ] = m[ j ][ i ];
         m[ j ][ i ] = tmp;
      }
}

int main( void ) {
   vector< vector<float> > matrix = {
      { 1, 2, 3 },
      { 4, 5, 6 },
      { 7, 8, 9 }
   };
   print( matrix );
   cout << "---------" << endl;
   trans( matrix );
   print( matrix );
}


============std::array=================

#include <iostream>
using namespace std;

float array[ (int)( 10. * 10. )  + 2 ];

int main( void ) {
   cout << "array size = "
        << sizeof( array ) / sizeof( array[ 0 ] )
        << endl;
}

$ ./siz1
array size = 102


Во всех таких случаях, после определения массива размер его фиксируется и мы не сможем никаким увеличить его размер (если, например, в ходе вычислений окажется, что нам не хватает этого размера)

============================
double *array = (double*)calloc( N, sizeof( double ) ); // это C
double *array = new double[ N ];                        // а это C++


=============================
для вектора предусмотрено 2 разных способа индексации: как операция [ i ] и как метод-функция at( i ). Они различаются: метод at() проверяет текущий размер вектора size(), и при индексации за его границу возбуждает исключение. Напротив, операция индексации не проверяет границу, что небезопасно, но зато это быстрее. Метод at() позволяет нам контролировать выход за границы вектора и либо квалифицировать это как логическую ошибку, либо корректировать текущий размер контейнера под потребность, как в вот таком фрагменте (здесь попыток доступа вдвое больше, чем реально выполненных операций):


int main( void ) {
   vector<int> nums;
   for( int i = 0; i < 10; ) {
      try {
         nums.at( i ) = i;    // vector::at throws an out-of-range
         i++;
      }
      catch( const out_of_range& ) {
         cout << i << " ";
         nums.resize( i + 1 );
      }
   }
   cout << endl << nums.size() << endl;
}

FizzBuzz
============================
Напишите программу, которая выводит на экран числа от 1 до 100. При этом вместо чисел, кратных трем, программа должна выводить слово Fizz, а вместо чисел, кратных пяти — слово Buzz. Если число кратно пятнадцати, то программа должна выводить слово FizzBuzz. Задача может показаться очевидной, но нужно получить наиболее простое и красивое решение.

#include <iostream>
using namespace std;
int main(){
  for(int i=1;i<101;i++)
  {
      if(i%3==0) cout<<"Fizz";
      if(i%5==0) cout<<"Buzz";
      if(i%3!=0 && i%5!=0) cout<<i;
      cout<<endl;
  }
}
=======================
#include <iostream>
#include <string>
using namespace std;
int main(){
  for(int i=1;i<101;i++)
  {
      string str="";
      if(i%3==0) str="Fizz";
      if(i%5==0) str+="Buzz";
      if(str=="") str=to_string(i);
      cout<<str+'\n';
  }
}
===========TUPLE===============

A tuple is a variadic class template that stores an unlimited set of values of different types, defined when instantiating the tuple; for example:

tuple<int, int> x;

will store 2 integers.

tuple<string, int, bool> y;

will store one string, one integer and one boolean and so on.


Tuples are useful for several things:

They are light replacements for structures.
They can be useful to return several values from a function
They let you perform comparisons through all the value set
You can instantiate tuples in these ways:

tuple<int, int, bool> x; //instantiating but not initializing
tuple<int, string> y { 2, "hello" }; //instantiating AND initializing
auto z = make_tuple(2, 3, 4, "bye"s); //instantiating AND initializing throught the make_tuple helper function.

#include <tuple>
#include <iostream>
#include <string>
using namespace std;

int main()
{
   auto xx = make_tuple(3.14, "PI"s);
   auto& first = get<0>(xx);
   auto& second = get<1>(xx);
   cout << "(" << first << "; " << second << ")" << endl;
   return 0;
}


int main()
{
  vector<tuple<int, string>> vec;
  vec.push_back(make_tuple(10, "ten"));
  vec.emplace_back(20, "twenty");
  vec.emplace_back(30, "thirty");

  for (auto& i : vec)
  {
     cout << "(" << get<0>(i) << "; " << get<1>(i) << ")" << endl;
  }
}

#include <iostream>
#include <set>
#include <string>
#include <tuple>

using namespace std;

using car = tuple<string, string, int>;

void print(const car& c)
{
    cout << get<0>(c) << ", " << get<1>(c) << "; " << get<2>(c) << endl;
}

int main()
{
  set<car> cars;
  cars.emplace("Toyota", "Rav4", 2012);
  cars.emplace("VW", "Jetta", 2015);
  cars.emplace("Chevrolet", "Sonic", 2013);
  cars.emplace("BMW", "X5", 2014);
  cars.emplace("VW", "Jetta", 2014);

  for (auto& i : cars)
    print(i);

  cout << "******" << endl;
  auto it = cars.find(car { "Toyota", "Rav4", 2012 });
  if (it == cars.end())
    cerr << "CAR NOT FOUND" << endl;
  else
    print(*it);

  return 0;
}
====== SFINAE ===============
 «substitution failure is not an error»

 for (const auto &item : vector) {
     .....
}
the same as
{
    auto it  (std::begin(vector));
    auto end (std::end(vector));

    for (; it != end; ++it) {
        const auto &item (*it);
        /* тело цикла */
    }
}
======= Ref counter pointer =========

struct refcntptrdata
{
  T* pointee;
  int refcnt;
};

template <typename T>
class refcntptr
{
  private:
    refcntptrdata<T>* data;

    void release()
    {
      data->refcnt--;
      if (data->refcnt == 0)
      {
        delete data->pointee;
        delete data;
      }
    }

  public:
    explicit refcntptr(T* pointee) : data(new refcntptrdata<T>())
    {
      data->pointee = pointee;
      data->refcnt = 1;
    }

    refcntptr(const refcntptr<T>& source) : data(source.data)
    {
      data->refcnt++;
    }

    refcntptr<T>& operator=(const refcntptr<T>& source)
    {
      release();
      data = source.data;
      data->refcnt++;
    }

    ~refcntptr()
    {
      release();
    }

    T* operator->() { return data->pointee; }
    const T* operator->() const { return data->pointee; }

    T& operator*() { return *(data->pointee); }
    const T& operator*() const { return *(data->pointee); }
};

std::vector — буфер выделяется в куче, размер неизвестен на этапе компиляции.
std::array — буфер выделяется на стеке, размер должен быть известен на этапе компиляции.

 данные в std::array могут жить как на стеке, так и на куче (например, если std::array используется как поле в классе, экземпляр которого размещения в куче)

https://habrahabr.ru/company/aligntechnology/blog/283352/

SMART POINTER
template <typename T>
class ptr
{
  private:
    T* pointee;

  public:
    explicit ptr(T* pointee) : pointee(pointee) { }
    ~ptr() { delete pointee; }

    T* operator->() { return pointee; }
    const T* operator->() const { return pointee; }

    T& operator*() { return *pointee; }
    const T& operator*() const { return *pointee; }
};




std::shared_ptr  std::make_shared https://habrahabr.ru/post/263751/
std::unique_ptr  std::make_unique

Example: naive, old style C++
Object *p = new Object()
p->use()
delete p

Previous example using unique_ptr
auto u=std::make_unique<Object>()
u->use()

Shared objects in C++
======================
void SharedObject(std::stared_ptr<Cookie>); may use and deleted object
auto sp = std::make_shared<Cookie>(dough, sugar, cinnamon);
sp->use()
SharedObject(sp) //share
sp->use()
SharedObject(std::move(sp))  //share and discard ownership

https://oopscenities.net/2013/10/06/smart-pointers-part-4-shared_ptr/
When shard pointer gets out of scope, the shared_ptr destructor is invoked automatically (because of RAII) and the reference counter is decremented again (this time to 0, because no shared_ptr is pointing anymore to the object).
Since the reference counter is 0, the object   destructor is invoked.
========================
auto_ptr --- deprecated.

auto cookie = std::make_unique<Cookie>(dough, sugar, cinnamon);

How to use following C func from C++?
======================================
void DoWork(int* buffer, size_t bufSize);

void Call(size_t n)
{
  std::vector<int> v(n);  // Лучше.
  DoWork(v.data(), v.size());
}


https://habrahabr.ru/post/311038/

Pimpl (pointer to implementation, указатель на имплементацию) — полезная идиома, распространенная в языке C++. У этой идиомы есть несколько положительных сторон, однако, в этой статье она рассматривается только как средство уменьшения зависимостей времени компиляции. Более подробно о самой идиоме можно посмотреть, например, здесь, здесь и здесь.


char buffer[32] = { 0 };

Тип кэша	Время доступа (тактов)	Размер кэша
Регистры	0	десятки штук
L1 кэш	4	32 KB
L2 кэш	10	256 KB
L3 кэш	50	8 MB
Оперативная память	200	8 GB
Буфер диска	100'000	64 MB
Локальный диск	10'000'000	1000 GB
Удалённые сервера	1'000'000'000	∞


Q: What is assignment operator?
A: Default assignment operator handles assigning one object to another of the same class.
Member to member copy (shallow copy)
All containers in the STL are parameterized with template arguments,
usually the last argument is called A or Allocator and defaults to std::allocator<...>
where ... represents the type of the value stored within the container.
The Allocator is a class that is used to provide memory and build/destroy the elements in this memory area.
It can allocate memory from a pool or directly from the heap, whichever you build the allocator from.
By default the std::allocator<T> is a simple wrapper around ::operator new and will thus allocate memory on the heap as you inferred.
The memory is allocated on demand, and is deallocated at the very least when the vector's destructor is called.
C++11 introduces shrink_to_fit to release memory sooner too. Finally, when the vector outgrow its current capacity, a new (larger) allocation is made,
the objects are moved to it, and the old allocation is released.
As will all local variables, the destructor is called when executed reaches the end of the scope it has been declared into.
So, before the function is exited, the vector destructor is called, and only afterward does the stack shrinks and control returns to the caller.
=========================================================
Base class object's pointer can invoke methods in derived class objects. You can also achieve polymorphism in C++
by function overloading and operator overloading.


===========================================================
Q: How do you know that your class needs a virtual destructor?
A: If your class has at least one virtual function, you should make a destructor for this class
virtual. This will allow you to delete a dynamic object through a caller to a base class object. If
the destructor is non-virtual, then wrong destructor will be invoked during deletion of the
dynamic object.
============
A: Inherits:
Every data member defined in the parent class (although such members may not always be accessible in the derived class!)
Every ordinary member function of the parent class (although such members may not always be
accessible in the derived class!)
The same initial data layout as the base class.
==================================================
Doesn't Inherit :
The base class's constructors and destructor.
The base class's assignment operator.
The base class's friends
===================================================
Q: What are VTABLE and VPTR?
A: vtable is a table of function pointers. It is maintained per class.
vptr is a pointer to vtable. It is maintained per object (See this for an example).
Compiler adds additional code at two places to maintain and use vtable and vptr.
1) Code in every constructor. This code sets vptr of the object being created. This code sets vptr to point to vtable of the class.
2) Code with polymorphic function call (e.g. bp->show() in above code).
Wherever a polymorphic call is made, compiler inserts code to first look for vptr using base class pointer or reference
(In the above example, since pointed or referred object is of derived type, vptr of derived class is accessed).
Once vptr is fetched, vtable of derived class can be accessed. Using vtable, address of derived derived class function show() is accessed and called.
==========================
emplace_back
emplace
=========================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define HELLO_STRING "Hello, Habr!\n"

void main() {
  char *str = malloc(sizeof(char) * (strlen(HELLO_STRING) + 1));
  strcpy(str, HELLO_STRING);
  printf("->\t%s", str);
  free(str);
}


===========   THREADS ==========
#include <cstdio>
#include <thread>

using namespace std;

void run()
{
    for (auto i = 0; i < 5; i++)
    {
        printf("%d\n", i);
    }
}

int main()
{
    thread t1(run);
    thread t2(run);
    thread t3(run);

    t1.join();
    t2.join();
    t3.join();
    return 0;
}
